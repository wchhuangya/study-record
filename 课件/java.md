# Java

[Toc]

## 第一章 语言概述

### 软件开发

#### 软件

**软件分类：**

1. 系统软件：各种操作系统（Windows、Linux、MacOS、鸿蒙等），主要是跟计算机硬件打交道的
2. 应用软件：影音类软件、编程软件、即时通信类软件等

**定义：**

一系列按照特定顺序组织的计算机数据和指令的集合

#### 软件开发

制作软件的过程，包括：需求阶段、设计阶段（UED、数据库、软硬件架构）、研发阶段、测试阶段、上线阶段、运行维护阶段

### 人机交互方式

1. 卡带式：早期的计算机占地面积大，计算能力弱，早期的程序员将准备好的二进制的计算机程序打在卡带上，然后将卡带插入计算机中，经过漫长的等待，计算机根据卡带上的二进制程序给出最终的结果
2. 命令行（问答式）：典型的黑底白字的界面，程序员输入一个命令，电脑根据输入的命令给出不同的反应：1. 命令输入正确，电脑给出相应的行为响应；2. 命令输入错误，电脑给出错误提示，或者无响应
3. 图形化界面：电脑将常用的命令组装成外设一键式的操作（比如鼠标、键盘等），复杂的命令可以通过简单命令的组合达到同样的效果

> 知识补充：常用的命令

### 发展历史

Java 是由 Sun 公司于 1995 年推出的一门编程语言：

* 1995 ~ 2004 年，Sun 公司先后推出了 JDK 1.2，1.3，1.4
* 2004 年，推出了 JDK 1.5，并改名为 JDK 5.0，这是一个划时代的版本，奠定了 Java 的江湖地位
* 2005 年，推出了 JDK 6.0
* JDK 7.0，8.0 是一年推出一个，9.0，10.0，11.0 更是达到了半年一个版本的速度进行推出
* Sun 公司于 2019 年 3 月份推出了 JDK 最新的版本 12.0

### 与其它语言的对比

* Java 真的不难学
  * 学习简单（相比 C、C++）
  * 面向对象（不支持多继续）
  * 程序健壮（强类型的语言，异常处理机制健全）
  * 程序安全（内存管理机制）
* Java 真的很强大
  * 全世界程序员使用最多的一门语言
  * 具有完备的生态圏
  * 拥有世界范围影响力的框架
  * 语言性能比较高效

### 运行机制

> Java 程序可以跨平台使用

1. 解释型语言：JavaScript，一边读取程序，一边对程序里的内容逐行进行解释，效率比较低，有错误不容易在编码时发现
2. 编译型语言：Java，需要一个解释器来将程序源码编译为电脑可以运行的可执行文件
   1. 写代码源文件
   2. 使用 JavaC.exe 将源文件编译为相应的 class　文件（字节码文件）
   3. 使用 Java.exe 工具解释这个字节码文件，生成直接可以运行的二进制文件，交给 CPU 运行

### JVM

Java Virtual Machine，Java 虚拟机，目的是为了解析 Java 语言

> 它是 Java 语言跨平台的关键

### JDK 和 JRE

* JRE -- Java Runtime Environment，Java 运行时环境，主要包含了 Java 运行时的必要元素（如：JVM 运行时需要的支持）
* JDK -- Java Development Kits，Java 开发工具包，有 Sun 公司免费提供的 Java 开发的工具，是一种 SDK，Software Development Kits，软件开发工具包

> JDK 与 KRE 之间相互依赖，缺一不可

### Java 开发环境安装

1. 获取安装包
2. 安装 Java 开发环境
3. 配置 Java 环境变量

## 第二章 数据类型与运算符

### HelloWorld

```java
class Hello {
    public static void main(String[] args) {
        System.out.println("Hello World！");
    }
}
```

这一段代码要注意的点：

* 目前我们所接触到的代码都是写在类 class 中的
* 类名与文件名称相同
* 文件后缀是：`.java`
* main 方法的写法是固定写法
* 语句后面用分号结尾
* 注意代码的缩进和必要的空格，这样可以让代码保持良好的阅读性

编译&运行代码：

* 使用 `> javac Hello.java` 命令将刚刚写的源代码编译为相应的字节码
* 使用 `> java Hello` 命令将上一步生成的字节码文件生成可执行的二进行文件并运行
* 在控制台上，你将看到 `> Hello World!` 的输出内容

### IntelliJ IDEA

使用 `IDEA` 编写 `HelloWorld` ：

* 从 [官网]() 下载 `IntelliJ IDEA`，注意：只下载 `2020.2.3` 这一版本，主要是为了后面的破解
* 点击安装
* 打开 `IDEA` ，选择 `Create Project` ，在 `New Project` 界面的左侧，选择 `Java` ，确保右边的 `Project SDK` 是电脑上已经安装好的 `JDK 1.8`
* 创建项目名称，指定项目存放的位置

#### 快捷键

* 单行注释：<kbd>command</kbd> + <kbd>/</kbd>
* 多行注释：<kbd>ctrl</kbd> + <kbd>shift</kbd> + <kbd>/</kbd>

### 标识符

代码中使用的一些名字，例如：

* 变量名
* 方法名
* 接口名
* 类名
* ……

#### 命名规范

* 标识符可以使用的字符范围：a～z，A～Z，0-9，_
* 标识符必须以英文字母开头
* 标识符严格区分大小写
* 标识符需要做到：见名知义
* 标识符需要用到驼峰命名法：
  
  * 大驼峰：所有单词的首字母都要大写；一般适用于 class 类名
  * 小驼峰：首字母小写，之后的每一个单词的首字母大写；一般适用于变量名、方法名
* 已经被 `Java` 或者系统占有的标识符不能使用，关键字和保留字不能使用
  
  > 例如 HelloWorld 程序中，变颜色的单词都不能使用

### 基本数据类型

| 整形  | 占据内存空间大小 |       数据范围        |
| :---: | :--------------: | :-------------------: |
| byte  |  1字节（8bit）   |     $ -127～128 $     |
| short |  2字节（16bit）  |   $ -32767～32768 $   |
|  int  |  4字节（32bit）  | $ -2^{31}～2^{31}-1 $ |
| long  |  8字节（64bit）  | $ -2^{63}～2^{63}-1 $ |

| 浮点型 | 占据内存空间大小 |       数据范围       |
| :----: | :--------------: | :------------------: |
| float  |  4字节（32bit）  | $ \pm3.4 * 10^{38} $ |
| double |  8字节（64bit）  |     $ 10^{308} $     |

| 字符型 | 占据内存空间大小 |   数据范围   |
| :----: | :--------------: | :----------: |
|  char  |  2字节（16bit）  | 可以保存中文 |

| 布尔类型 | 占据内存空间大小 |  数据范围   |
| :------: | :--------------: | :---------: |
| boolean  |    视情况而定    | true  false |

### 变量

变量是计算机内存中的一块存储空间，是存储数据的基本单元

格式：`数据类型 变量名 = 初始化数据;` 

> 变量名里面保存的数据，可以在程序的运行过程中发生改变

数据类型：约束当前变量是什么类型

变量名：方便操作变量的名字

= 赋值号：把赋值号右侧的数据赋值给左侧变量名

初始化数据：给变量赋值相应数据类型的值

```java
class Demo1 {
    public static void main(String[] args) {
        // 定义一个 int 类型的变量
        int nums = 100;
        System.out.println(nums);
    }
}
```

### 数据类型转换

主要是为了满足数据类型一致化的问题，在不同数据类型之间做数据的转换操作的一种方式。

#### 自动类型转换

核心思想就是小数据类型转换为大数据类型。

算数运算的规则：

1. 两个操作数有一个是 double，计算结果提升为 double
2. 两个操作数没有 double，但是有一个 `float`，计算结果提升为 `float`
3. 如果操作数中没有 `float`，有一个为 `long`，计算结果提升为 `long`
4. ……
5. 你看出来什么规律了吗？

> 1. 如果操作数中只有 short 或者 byte，那么最终的结果会被提升为 int
> 2. 任何类型与 String 类型相加时（+），实际为拼接，其结果自动提升为 String

```java
byte num1 = 10;
int num2 = 20;

num2 = num1 + num2;
// 问：最终，num2 是什么数据类型，为什么？
```

#### 强制类型转换

核心思想就是将大数据类型转换为小数据类型

```java
float num1 = 3.14F;
int num2 = 10;

num2 = num1 + num2; // 这里会有编译报错

// 正确的写法是：
num2 = (int) (num1 + num2);

// 问：最终 num2 是什么数据类型，值为多少？
```

* 利：可以满足数据类型的一致性要求
* 弊：原数据类型的强制转换过程中，会导致数据精度丢失，而且这样的丢失是不可逆的

### 运算符

#### 赋值运算符

`=` ：把左边的值赋值给右边的变量

#### 复合赋值运算符

`+=  -=  *=  /=  %=`

#### 算术运算符

`+、-、*、/、%、()` ：加、减、乘、除，求余 

规则：

* 从左到右
* 先乘除，后加减
* 除数不能为0
* 有括号先处理括号里的内容

`%` 针对的是两个整数，获得的结果是不能整除后的余数，如果可以整除，结果为 0 

```java
class Demo {
    public static void main(String[] args) {
        int num1 = 10;
        int num2 = 20;

        num1 = num1 + num2; // num1 = ? num2 = ?
        num1 = num1 - num2; // num1 = ? num2 = ?
        num1 = num1 * num2; // num1 = ? num2 = ?
        num1 = num1 / num2; // num1 = ? num2 = ?
        num1 = num1 % num2; // num1 = ? num2 = ?
    }
}
```

`+=、-=、*=、/=、%=` ：这些是复合运算符，作用是简化书写

```java
int num1 = 1, num2 = 2;

num1 += num2; // => num1 = num1 + num2
```

##### 自增、自减

> 1. 该运算符很好用，但是容易引起阅读者的理解困难，或者引起初学者的困惑，小心使用
> 2. 这两个都是 一元运算符

`++` 、`--` ：

* 放在变量之后，首先执行当前语句，然后再执行自增、自减操作
* 放在变量之前，首先执行自增、自减操作，然后再执行当前语句

```java
int num1 = 1, num2 = 2;
System.out.println(num1++ + ++num2); // 最后结果是什么？为什么？
// 现在 n1 和 n2 的值又变成了什么
System.out.println(num1);
System.out.println(num2);
```

#### 比较运算符

`>  >=  <  <=  !=  ==`    这是 Java 中的写法

$>$   $ \geq $    $ < $    $ \leq $     $ \neq $      $ = $    这是数学中的表示法

关系运算符的结果是 **布尔值**

```java
System.out.println(4 > 3); // 结果是？
System.out.println(5 < 4); // 结果是？
System.out.println(3 >= 3); // 结果是？
System.out.println(6 != 8); // 结果是？
System.out.println(9 == 9); // 结果是？
```

#### 位运算符

`& | ^ ～ << >> >>>`  ：

* 按位与：同1为1，不同为0
* 按位或：有1为1，无1为0
* 按位异或：相同为0，不同为1
* 按位非：0变1，1变0（单目运算符）
* 左移：向左移动X位（在右边补X个0，单目运算符）
* 右移：向右移动X位（在左边补X个0，单目运算符）
* 无符号右移：不管符号位，其余与右移一样

#### 逻辑运算符

`&&` ：逻辑与，同真为真，有假为假

`||` ：逻辑或，有真即真，同假为假

`!` ：取反

```java
System.out.println(4 > 3 && 5 > 4);
System.out.println(4 > 3 || 5 > 6);
System.out.println(!(false));
```

##### 逻辑与的断路原则

```java
int num1 = 1, num2 = 2;
boolean res = num1 > 3 && num2++ > 10;

System.out.println(num1); // 结果？
System.out.println(num2); // 结果？
```

##### 逻辑或断路原则

```java
int num1 = 1, num2 = 2;
boolean res = num1 > 0 || num2++ > 10;

System.out.println(num1); // 结果？
System.out.println(num2); // 结果？
```

#### 三元运算符

`? : ` ：将判断后的结果赋值给变量

```java
boolean res = 3 > 5 ? false : true;
```

### 控制台输入

程序运行以后，在控制台输入一定的数据，然后程序继续运行

1. 导入工具包：`import 包名.类名`
2. 声明变量： `Scanner scanner = new Scanner(System.in);`
3. 使用 `Scanner` 中的方法

```java
import java.util.Scanner

class HaHa {
    public static void main(String[] argss) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入内容：");
        int num = scanner.nextInt();
        System.out.println("你输入的内容是：" + num);
    }
}
```

> Scanner 的三个常用方法：
>
> * nextInt()
> * nextDouble()
> * next()

### 表达式

使用运算符连接的变量或者字面值，并且可以得到一个最终结果

```java
1 + 2;
int a = 3;
d > e;
```

## 第三章 选择结构与分支结构

### 选择结构 If

根据已知条件进行逻辑判断，满足条件后执行相应判断

```java
if (布尔表达式) {
    // 代码块
} else if (布尔表达式) {
    // 代码块
} 
...
else {

}
```

> 1. 以上代码块相互排斥，有一个为 true，其他均不再执行，适用于区间判断
> 2. 嵌套语法正确的情况下，if 语句可以任意嵌套

### 分支结构 switch

对变量或者表达式进行判断，根据判断的结果选择相应的分支

```java
switch (变量 | 表达式) {
        case 值1：
            代码1;
        case 值2：
            代码2;
        case 值n：
            代码n;
        default:
            未满足上述条件时的逻辑运算;
}
```

1. 可以用于判断的类型：`byte、short、int、char、String（JDK7+）`
2. 每个 `case` 中都可以使用 `break` 来中断匹配的继续

> 一定要养成良好的习惯，在每个 case 分支中尽可能把 break 都写上，否则会引发问题

### 循环结构

#### while

```java
while (布尔表达式) {
    // 逻辑代码
}
```

执行流程：

1. 先对布尔表达式进行判断，结果为 `true` 时，才执行逻辑代码
2. 本次执行完成后，会对布尔表达式进行再次判断，判断结果为 `true` 时，再执行逻辑代码
3. 直到布尔表达式的结果为 `false` 时，就会退出循环结构

特点：

* 先判断，再执行：首次判断条件不满足时，一次循环内容都不会执行

#### 循环的主要构成

1. 初始部分：用于判断的变量
2. 循环条件：决定是否继续循环的依据
3. 循环内容：循环的单次执行的代码内容
4. 迭代部分：控制循环变量的改变

#### do while

```java
do {
    // 逻辑代码
} while (布尔表达式)
```

执行流程：

1. 先无条件的执行一次逻辑代码，然后进行条件判断
2. 当结果为 `true`，则再次执行循环体内容
3. 当结果为 `false`，结束循环，执行后续代码

特点：

1. 没有入口条件，先执行，后判断

#### for

```java
for (初始部分；循环条件；迭代部分) {
    // 逻辑代码
}
```

执行流程：

1. 执行初始部分（只有一次）
2. 对循环条件进行判断，如果为 `true`，则执行逻辑代码
3. 逻辑代码执行完成后，进行迭代部分
4. 迭代完成后，再次进行循环条件的判断，如果为 `true`，继续执行逻辑代码
5. 循环条件判断的结果为 `false`，退出循环结构

特点：

1. 先判断，再执行
2. 适用于次数明确的循环

### 流程控制语句

#### break

作用：终止、跳出 `switch`、循环语句

#### continue

作用：结束本次循环，进入下次循环

### 嵌套循环

在一个完整的循环结构中，嵌套另外一个完整的循环结构

作业：

1. 有一个式子：$1×2×3×...×n=m$，使用程序算出当m小于5000时n最大是多少？
2. 在控制台输入五个整数，用程序算出这五个数最大值和最小值分别是多少？
3. 把区间 (100,200) 中不能被3整除的数输出，每一行输出 4 个数字。
4. 有1、2、3、4这4个数字，能组成多少个没有重复数字的三位数？打印出来
5. 使用程序计算：$ (1×1) + (1×2) + (1×2×3) + (1×2×3×4) + (1×2×3×4×5) $ 的值
6. 控制台输入一个值，根据该值在控制台上用 * 绘制四个直角等腰三角形，直角边的长度等于输入的值，这4个三角形的斜边分别在右上、左上、右下、左下

## 第四章 方法/函数

### 方法的概念

概念：实现特定功能的一段代码，可以反复使用

### 方法的定义

```java
public static void 方法名称() {
    // 方法主体
}
```

经验：将需要在多个地方重复使用后段代码，定义在方法内部

位置：在类的内部，与 `main` 方法并列

```java
// 位置1
public class {
    // 位置2
    public static void main(String[] args) {
        // 位置3
    }
    // 位置4
}
// 位置5
```

> 1. 一个类中可以定义多个方法，方法之间是平行关系，不能嵌套
> 2. 一个方法只做一件事情

### 方法的调用

```java
public class Test {
    public static void main(String[] args) {
        System.out.println("床前明月光，");
        printStr();
        System.out.println("疑是地上霜。");
        printStr();
        System.out.println("举头望明月，");
        printStr();
        System.out.println("低头思故乡。");
        printStr();
    }
    // 自定义方法，用于打印分隔字符
    public static void printStr() {
        for (int i = 0; i < 10; i++) {
            System.out.print("-");
        }
        System.out.println();
    }
}
```

调用方法时，会优先执行方法内部代码，结束后，返回到方法调用处，继续向下执行。

### 方法的组成

在大多数情况下，方法需要与调用者进行一些数据的交互，通常，数据的交互是由方法的参数和返回值来完成的。

参数：调用方法时，传给方法的数据

#### 形参

```java
public static void 方法名(形参) {
    // 方法体
}
```

形参又等价于局部变量

#### 实参

在调用有形参的方法时，需要传入对应的参数，调用方法时传递的参数被称为实参

#### 方法参数的作用

1. 可以让方法更灵活
2. 可以让方法普遍性、适应性更高
3. 可以让方法易于修改及维护

> 调用有参的方法时，实参的个数与类型必须与形参列表完全一致

根据实际的业务定义方法的参数

#### 值传递 VS 地址传递

1. 简单数据类型 `VS` 复杂数据类型

    1.1 简单数据类型：`int,double,float,char,boolean`
    
    1.2 复杂数据类型：数组，对象
    
2. 简单数据类型是 **值传递**，即方法内值的改变不会影响方法外参数的值
3. 复杂数据类型是 **地址传递**，即方法内任何改变都会影响原有数据

#### 返回值与返回类型

方法执行后，一些情况下不需要返回值，有些情况必须得有返回值

```java
public static 返回值类型 方法名称(形参列表) {
    // 方法体
    return value; // 返回
}
```

* 返回值类型规定了返回值的数据类型（基本类，引用类型，`void`）
* `return` 后面跟具体的返回值，也可以应用在没有返回值类型（`void`）的方法中  
* 可以使用变量接收方法的返回值，要求：变量类型与返回值类型必须一致
* 一个方法只能有一个返回值
* 当具有返回值的方法存在分支结构时，必须保证每一个分支都返回合适类型的值

#### continue、break、return 的区别

1. continue：跳出本次循环，继续下一次循环
2. break：跳出循环体，继续执行循环体之外的函数体
3. return：跳出整个函数体，函数体后面的部分不再执行

### 递归

为了解决具备某种规矩的问题时，在方法内部再次调用自身方法的和种编程

#### 使用时机

1. 当需要解决的问题可以被拆解为若干个解决方法相同的问题时，方法中调用方法本身
2. 使用循环解决的常规问题，都可以替换为递归解决

#### 使用方法

* 设置有效的出口条件，可以让方法得以正确返回，避免无穷递归
* 递进：每一次推进，计算都比上一次变得简单，直至简单到无需继续推进，就能获得结果，也叫达到出口
* 回归：基于出口的结果，逐层向上回归，依次计算每一层的结果，直到回归到最顶层

> 所有递归能解决的问题，循环都可以解决，但在解决复杂问题时，递归的实现方式更为简单

## 第五章 数组

概念：一组连续的存储空间，存储多个相同数据类型的值

特点：数据类型相同；数组长度固定

### 创建

先声明，再分配数组空间

```java
数据类型[] 数组名称 = new 数据类型[数组长度]

// 1. 先声明，再分配数组空间
int[] array1;
array1 = new int[4];

// 2. 声明并分配空间
int[] array1 = new int[4];

// 3. 声明并赋值
int[] array1 = new int[]{1, 2, 3};

// 4. 声明并赋值（简化版）
int[] array1 = {1, 2, 3};

// 注意：3、4 两种方式有一些细微的差别
// 3 可以写为两行：
// int[] array1;
// array1 = new int[]{1, 2, 3};
// 但是 4 不可以这样写
```

### 术语

* 数组中的每个数据被称为：**数组元素**
* 对数组中每个元素进行赋值或取值的操作被称为：**元素的访问**
* 访问数组元素时，需要使用下标：**下标从0开始，依次加1，自动生成**

### 数组元素存取

* 获取：`数组名称[下标]`
* 存入：`数组名称[下标] = 值`

### 下标

范围：`0 ~ 数组长度-1`

> 如果访问或者存入一个不存在的下标，会报出 java.lang.ArrayIndexOutOfBoundsException 的异常

### 遍历

从头至尾，逐一对数组的每个元素进行访问

```java
public static void main(String[] args) {
    int[] arr = new int[5];

    for (int i = 0; i < 5; i++) {
        arr[i] = i + 1;
    }

    for (int i = 0; i < 5; i++) {
        System.out.println(arr[i])
}
}
```

**length** ：获取数组的长度

### 数组元素的默认值

数组在没有初始化之前，和数组的类型相关，系统都会对数组的元素做相应的初始化操作。

数组元素默认值：

* 整数：`0`
* 小数：`0.0`
* 字符：`\u0000`
* 布尔：`false`
* 其它：`null`

### 随堂练习

1. 给定一个整数数组，数组中的值自己指定/从控制台中获取，统计数组中所有元素的平均值。
2. 从控制台输入一个数字，在一个已经存在的数组中进行判断，如果该数字在数组中存在，输入数字在数组中的下标，如果不存在，输出 `-1`

### 数组的排序

`java.util.Arrays.sort(数组名)` ：对数组中的元素进行升序排序

## 第六章 面向对象

### 概念

* 一切客观存在的事情都是对象，**万物皆对象**
* 任何对象，一定具有自己的特征和行为

> 特征：也叫做属性，一般为名词，代表对象有什么
>
> 行为：也叫做方法，一般为动词，代码对象能做什么

### 使用对象解决问题

1. 将现实中的对象定义为程序里的对象，用来模拟现实世界
2. 用程序中的对象代表现实中的对象，解决实际的问题

### 如何定义对象

现实中的事物产生，一般都会有个模板，根据模板，再创造出各种事物对象。

程序中也有个模板，用以产生对象，这个模板在程序中被叫做 **类**。由程序中的类所产生的实体被叫做程序中的 **对象**。

### 类

```java
public class Dog {

    String breed; // 定义品种
    int age; // 定义年龄
    String sex; // 定义性别
    String color; // 定义颜色

    // 吃东西的方法
    public void eat() {
        System.out.println("eating...");
    }

    // 睡觉的方法
    public void sleep() {
        System.out.println("sleeping...");
    }
}
```

#### 属性

1. 类的属性通过变量表示，又被称作实例变量
2. 与变量的声明相同
3. 属性的声明位于类的内部，方法的外部

#### 方法

1. 通过函数表示，又被称作实例方法
2. 定义：
  
   ```java
   public 返回值类型 方法名(形参) {
       // 方法
   }
   ```

#### 创建对象

```java
public class JingBa {
    public static void main(String[] args) {
        Dog jingBa = new Dog();

        jingBa.bread = "京巴";
        jingBa.age = 3;
        jingBa.sex = "公";
        jingBa.color = "白";

        jingBa.eat();
        jingBa.sleep();
    }
}
```

> 1. 给对象的属性赋值的方法：对象.属性 = 值;
> 2. 调用对象行为的方法：对象.方法();
> 3. 获取对象属性值的方法：对象.属性

#### 类与对象

* 类定义了对象应具有的属性与行为，类是对象的模板
* 对象拥有多个特征和行为的实体，对象是类的实例

#### 实例变量

|          | 实例变量（field）              | 局部变量（variable）           |
| -------- | ------------------------------ | ------------------------------ |
| 定义位置 | 类的内部，方法的外部           | 方法或方法内的结构当中         |
| 默认值   | 字面值（与数组相同）           | 无默认值                       |
| 使用范围 | 本类有效                       | 从定义行开始到包含其的结构结束 |
| 命名冲突 | 可与局部变量重名，局部变量优先 | 不允许重名                     |

##### 默认值

| 数据类型              | 默认值   |
| --------------------- | -------- |
| byte                  | 0        |
| short                 | 0        |
| int                   | 0        |
| long                  | 0L       |
| float                 | 0.0f     |
| double                | 0.0d     |
| char                  | '\u0000' |
| String(or any Object) | null     |
| boolean               | false    |

##### 字面值

基本类型是内置于语言中的特殊数据类型；它们不是从类创建的对象。字面值是固定值的源代码表示；字面值直接在代码中表示，不需要计算。

###### 整形字面值

```java
// 十进制
int num = 10;
// 十六进制
int num = 0xa;
// 二进制
int num = 0b1010;
// 八进制
int num = 012;
```

###### 浮点字面值

```java
// 长整形
long num = 10L;
// 单精度浮点
float num = 10.0f/F;
// 双精度浮点
double num = 10.0d/D;
// 科学计数法
double num = 0.01e3
```

###### 字符、字符串字面值

字符字面值使用单引号包裹 `'` ，字符串字面值使用双引号包裹 `"` ，`Unicode` 转义序列可以使用在程序的任何地方（例如字段名等）。

**ASCII 码表：**
![image-20201127084720407](/Users/wchya/own/markdown/imgs/image-20201127084720407.png)

**转义字符：**

![image-20201127084654609](/Users/wchya/own/markdown/imgs/image-20201127084654609.png)

###### 在数字字面值中使用下划线 `_` 分隔

在 `Java SE 7` 及以后版本中，数字字面值中可以出现任意数量的下划线字符(`_`)，这样可以提高代码的可读性。

**注意：** 只能在数字字面值中添加下划线，并且在数字字面值的以下情况中也不能添加下划线：

* 数字的开始或结尾
* 浮点数字中，与小数点相邻的位置
* `F` 或者 `L` 后缀的前面
* 在完整的数字串之间

```java
// 错误：在 . 前后出现 _
float pi1 = 3_.1415F;
float pi2 = 3._1415F;
// 错误：在 L 之前出现 _
long socialSecurityNumber1 = 999_99_9999_L;
// 错误：在 0x 之间出现 _ （0x 是完整的数字串）
int x4 = 0_x52;
// 错误：在数字字面值的开始或结尾
int x5 = 0x_52;
int x2 = 52_;

// 正确
int x1 = 5_2;
// 正确
int x3 = 5_______2;
// 正确
int x6 = 0x5_2; 
```

#### 实例方法

##### 方法的声明

`修饰符 返回值类型 方法名(形参列表)`

##### 方法的重载

有些情况下，对象的同一种行为可能存在不同的实现过程。

方法重载（**overload**）：一个类中定义多个相同名称的方法

要求：

* 方法名称相同
* 参数列表不同（类型、个数、顺序）
* 与访问修饰符、返回值类型无关

调用：

* 根据传入的实参找到实际调用的方法

#### 构造方法/构造器

类中的一个特殊方法，主要用于创建对象

特点：

* 名称与类名完全相同
* 没有返回值类型
* 创建对象时，就可以调用构造方法
* 如果类中没有显式定义构造方法，则编译器默认会提供一个无参的构造方法
* 类中如果有其它的构造方法，系统就不会添加无参的构造方法了

#### 创建对象的过程

1. 在内存中开辟一个空间，并赋值属性为默认值
2. 调用构造方法初始化
3. 把对象地址赋值给变量

#### **this** 关键字

类是模板，可以创建很多对象。**this** 是类中的默认引用，代表当前实例，当类服务于某个对象时，**this** 则指向这个对象

用法：

1. 调用实例属性、方法
2. 调用本类中的其它构造方法
  
   1. 构造方法中调用其它构造方法要注意，必须是第一条语句，且只能调用一次

### 三大特性

面向对象的核心

#### 封装

在对象的外部，为对象的属性赋值，可能存在非法数据的录入。

**概念：**

尽可能的隐藏对象的内部实现细节，控制对象的修改及访问的权限。

**实现：**

将对象的属性改为 `private`（私有的），同时添加属性公共的访问方法，在访问方法中对属性的赋值的合理性做控制

```java
class Student {
    private String name;
    private int age;
    private String sex;
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getName() {
        return this.name;
    }
    
    public void setAge(int age) {
        if (age >0 && age <= 100) {
            this.age = age;
        } else {
            this.age = 18;
        }
    }
    
    public int getAge() {
        return this.age;
    }
    
    public void setSex(String sex) {
        if ("男".equals(sex) || "女".equals(sex)) {
            this.sex = sex;
        } else {
            this.sex = "男";
        }
    }
}
```

**总结：**

`get、set` 方法是外界访问对象私有属性的唯一通道，方法内部可以对数据朝廷检测和过滤

#### 继承

两个类之间的继承关系，必须满足 `is a` 的关系

被继承的类：**父类（超类）**

继承的类：**子类（派生类）**

**父类的抽象：**

可以根据程序需要使用到的多个具体类，进行共性抽取，进而定义父类

##### 语法

`class 子类 extends 父类 {}  // 定义子类时，显式继续父类`

产生继续关系后，子类可以使用父类的属性和方法，也可以定义子类独有的属性和方法

好处：提高代码的复用性，又可以提高代码的可扩展性

`java` 中的继承为单继承，即每个类只能有一个直接父类，但是可以多级继承，属性和方法逐级叠加

```java
class Animal {
    String breed;
    String name;
    
    public void sleep() {
        System.out.println("Sleeping ...");
    }
    
    public void eat() {
        System.out.println("Eating ...");
    }
}

class Dog extends Animal {
    // 就算 Dog 类中什么都不写，此时也继承了父类 Animal 中可以继承的（具体见访问修饰符表）属性和方法
}
```

**类中不可以被继承的内容**

* 构造方法
* `private` 修饰的属性和方法
* 父子类不在同一个 `package` 中，`default` 修饰的属性和方法

**访问修饰符（可见性：✓可见，✕不可见）：**

|               | 本类 | 同包 | 非同包子类 | 其它 |
| ------------- | :--: | :--: | :--------: | :--: |
| **private**   |  ✓   |  ✕   |     ✕      |  ✕   |
| **default**   |  ✓   |  ✓   |     ✕      |  ✕   |
| **protected** |  ✓   |  ✓   |     ✓      |  ✕   |
| **public**    |  ✓   |  ✓   |     ✓      |  ✓   |