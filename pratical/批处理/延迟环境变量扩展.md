> 本文来源于网络：[https://www.jb51.net/article/29323.htm](https://www.jb51.net/article/29323.htm)

设置本地为延迟扩展。其实也就是：延迟变量，全称延迟环境变量扩展, 想进阶，变量延迟是必过的一关！

为了更好的说明问题，我们先引入一个例子：

<a id="1"> </a>例1：

```shell
@echo off
set a=4
set a=5&echo %a%
pause
```

输出结果：4

解说：为什么是4而不是5呢？在echo之前明明已经把变量a的值改成5了？

让我们先了解一下批处理运行命令的机制：批处理读取命令时是按行读取的（另外例如for命令等，其后用一对圆括号闭合的所有语句也当作一行），在处理之前要完成必要的预处理工作，这其中就包括对该行命令中的变量赋值。

我们现在分析一下<a href="#1">例1</a>，批处理在运行到这句 `set a=5&echo %a%` 之前，先把这一句整句读取并做了预处理——对变量 a 赋了值，那么 %a% 当然就是 4 了！（没有为什么，批处理就是这样做的。）

而为了能够感知环境变量的动态变化，批处理设计了变量延迟。简单来说，在读取了一条完整的语句之后，不立即对该行的变量赋值，而会在某个单条语句执行之前再进行赋值，也就是说“延迟”了对变量的赋值。

那么如何开启变量延迟呢？变量延迟又需要注意什么呢？

举个例子：

<a href="2"> </a>例2：

```shell
@echo off
setlocal enabledelayedexpansion
set a=4
set a=5&echo !a!
pause
```

解说：由于启动了变量延迟，得到了正确答案。变量延迟的启动语句是 `setlocal enabledelayedexpansion`，并且，后面使用的变量要用一对叹号 `!!` 括起来（注意要用英文的叹号），否则就没有变量延迟的效果。

分析一下<a href="#2">例2</a>，首先 `setlocal enabledelayedexpansion` 开启变量延迟，然后 `set a=4` 先给变量 a 赋值为4，`set a=5&echo !a!` 这句是给变量a赋值为5并输出（由于启动了变量延迟，所以批处理能够感知到动态变化，即不是先给该行变量赋值，而是在运行过程中给变量赋值，因此此时a的值就是5了）。

再举一个例子巩固一下。

<a href="3"> </a>例3：

```shell
@echo off 
setlocal enabledelayedexpansion 
for /l %%i in (1,1,5) do ( set a=%%i echo !a! ) 
pause
```

结果：

```shell
1
2
3
4
5
```

解说：本例开启了变量延迟并用 `!!` 将变量扩起来，因此得到我们预期的结果。如果不用变量延迟会出现什么结果呢？

结果是这样的：ECHO 处于关闭状态。ECHO 处于关闭状态。ECHO 处于关闭状态。ECHO 处于关闭状态。ECHO 处于关闭状态。即没有感知到 for 语句中的动态变化。