[TOC]

# Python

## 环境搭建

## 词法

### 编码声明

如果一条注释位于 Python 脚本的第一行或第二行，并且匹配正则表达式 `coding[=:]\s*([-\w.]+)` ,这条注释会被作为编码声明来处理。编码声明必须独占一行，如果它是第二行，则第一行也必须是注释。推荐的编码声明形式如下：

`# -*- coding: <encoding-name> -*-`

> 如果没有编码说明，则默认编码为 UTF-8

### 行拼接

两个或更多物理行可使用反斜杠字符 `\` 拼接为一个逻辑行，规则如下：

当一个物理行以一个不在字符串或注释内的反斜杠结尾时，它将与下一个拼接构成一个单独的逻辑行，反斜杠及其后面的换行符会被删除：

```python
if 1900 < year < 2100 and 1 <= month <= 12 \
   and 1 <= day <= 31 and 0 <= hour < 24 \
   and 0 <= minute < 60 and 0 <= second < 60:   # Looks like a valid date
        return 1
```

> 注意：
>
> 1. 以反斜杠结束的行不能带有注释
> 2. 反斜杠不能用来拼接注释

圆括号、方括号或花括号以内的表达式允许分成多个物理行，无需使用反斜杠：

```python
month_names = ['Januari', 'Februari', 'Maart',      # These are the
               'April',   'Mei',      'Juni',       # Dutch names
               'Juli',    'Augustus', 'September',  # for the months
               'Oktober', 'November', 'December']   # of the year
```

> 注意：
>
> 1. 这种情况可以带注释
> 2. 后续行的缩进不影响程序结构
> 3. 后续行也允许为空白行

## 数据类型

### 进制转换

#### 其它进制转十进制

```python
# 二进制转十进制
print(int('100', 2))
# 八进制转十进制
print(int('040', 8))
# 十六进制转十进制
print(int('0x40', 16))

# 以下是输出
4
32
64
```

#### 十进制转其他进制

```python
# 十进制转二进制
print(bin(40))
# 十进制转八进制
print(oct(40))
# 十进制转十六进制
print(hex(40))

# 以下是输出
0b101000
0o50
0x28
```

## 变量 & 关键字

### yield

yield 表达式在定义 generator 函数或是 匿名 generator 的时候才会用到。因此只能在函数定义的内部使用 yield 表达式。

在一个函数内部使用 yield 表达式会使这个函数变成一个生成器。

```python
def Test():
    print('开始喽……')
    while True:
        res = yield 4
        print('res: ', res)

# 该句实例化，因为有 yield 存在，所以并没有执行什么
test = Test() 
# 该句用于输出 test 迭代器的下一个值。注意：yield 相当于 return，程序读取到这个关键字时，就会从当前位置退出，将 yeild 右边的值返回，并且记录当前退出的位置，变量、运行环境等的当前状态，用于后面的返回
print(next(test)) 
# 打印 30 个 *
print('*' * 30)
# send 方法向程序发送数据，并回到离开时的位置。将值赋给 res 变量，然后打印。函数再次执行，直到碰到 yield 关键字就退出程序，并返回 yield 右边的值
print(test.send(8))

# 以下是输出
开始喽……
4
******************************
res:  8
4
```

#### 结论

一个带有 yield 的函数就是一个 generator，它和普通函数不同，生成一个 generator 看起来像函数调用，但不会执行任何函数代码，直到对其调用 next()（在 for 循环中会自动调用 next()）才开始执行。虽然执行流程仍按函数的流程执行，但每执行到一个 yield 语句就会中断，并返回一个迭代值，下次执行时从 yield 的下一个语句继续执行。看起来就好像一个函数在正常执行的过程中被 yield 中断了数次，每次中断都会通过 yield 返回当前的迭代值。

#### 好处

yield 的好处是显而易见的，把一个函数改写为一个 generator 就获得了迭代能力，比起用类的实例保存状态来计算下一个 next() 的值，不仅代码简洁，而且执行流程异常清晰。

#### 判断函数是不理 generator 函数

```python
from inspect import isgeneratorfunction
isgeneratorfunction(fab) 
```

#### 实例

```python
def read_file(fpath): 
    BLOCK_SIZE = 1024 
    with open(fpath, 'rb') as f: 
        while True: 
            block = f.read(BLOCK_SIZE) 
            if block: 
                yield block 
            else: 
                return
              
# 以上的例子实现了文件的读取，每次 next 都会返回本次读取的文件内容
```

#### 小结

* 生成器能够迭代的关键是它有 next() 方法，工作原理就是通过重复调用 next() 方法，直到捕获一个异常
* 带有 yield 的函数不再是一个普通的函数，而是一个生成器 generator，可用于迭代
* yield 是一个类似于 return 的关键字，迭代一次遇到 yield 的时候就返回 yield 后面或右面的值。而且下一次迭代的时候，从上一次迭代遇到的 yield 后面的代码开始执行
* yield 就是 return 返回的一个值，并且记住这个返回的位置，下一次迭代就从这个位置开始
* 带有 yield 的函数不仅仅是只用于 for 循环，还可用于某个函数的参数，只要这个函数的参数也允许迭代参数
* send() 和 next() 的区别就在于 send 可传递参数给 yield 表达式，这时候传递的参数就会作为 yield 表达式的值，而 yield 的参数是返回给调用者的值，也就是说 send 可以强行修改上一个 yield 表达式值
* send() 和 next() 都有返回值，他们的返回值是当迭代遇到 yield 的时候，yield 后面表达式的值，其实就是当前迭代 yield 后面的参数
* 第一次调用时候必须先 next() 或 send()，否则会报错。send 之后之所以为 None 是因为这时候没有上一个 yield，所以也可以认为 next() 等同于 send(None)

### global 与 nonlocal 的区别

1. 两者的功能不同。global 关键字修饰变量后标识该变量是全局变量，对该变量进行修改就是修改全局变量；而 nonlocal 关键字修饰变量后标识该变量是上一级函数中的局部变量，如果上一级函数中不存在该局部变量，nonlocal 位置会发生错误（最上层的函数使用 nonlocal 修饰变量必定会报错）
2. 两者的适用范围不同。global 关键字可以用在任何地方，包括最上层函数中和嵌套函数中，即使之前未定义该变量，global 修饰后也可以直接使用；而 nonlocal 关键字只能用于嵌套函数中，并且外层函数中定义了相应的局部变量，否则会发生错误

#### 详细说明

1. 在函数内部使用了与全局变量同名的变量，如果不对该变量赋值（修改变量），那么该变量就是全局变量，如果对该变量进行赋值，那么该变量就是局部变量
2. global 关键字修饰函数内部变量后标志其是全局变量（这里不能说 global 将 x 从局部变量改为了全局变量），如果 global 修饰函数内的变量，必须在使用变量前进行修饰（否则会发生变量未定义的错误）
3. 如果在嵌套函数和函数（这里指包含嵌套函数的那个函数）中存在和全局变量同名的变量，如果直接使用，而不修改变量的值，那么这三个位置上使用的是同一个全局变量。如果在函数中修改了变量值，那么该变量会标识为函数的局部变量，嵌套函数直接使用时使用的是该函数的局部变量。如果在嵌套函数中修改同名变量的值，那么嵌套函数中的该变量会被标识为该嵌套函数的局部变量，它的修改不能影响函数中同名变量和全局变量
4. global 可以在任何地方修饰变量，而且被 global 修饰的变量直接被标识为全局变量，对该变量修改会影响全局变量的值，但不会影响函数中未被 global 修饰的同名变量（依然是局部变量），nonlocal 只能在嵌套函数中使用，用于标识嵌套函数中的变量是包含该嵌套函数的函数中的同名变量，在嵌套函数中修改变量会影响函数中的变量。如果在函数中使用 global 修饰了变量，那么在嵌套函数中用 nonlocal 修饰同名变量会发生报错，因为 nonlocal 表示该变量在函数中已经定义，但检查时因为同名变量被 global 修饰为全局变量，所以不存在同名的局部变量，从而导致错误

> 注意：
>
> 1. global 修饰变量时，不能直接赋值

## 运算符 & 操作对象

## 内建序列

### 通用操作

#### 索引

1. 对序列中单个元素进行访问
2. 序列中的每个元素都分配一个数字，代码它在序列中的位置（索引）
3. 索引从 0 开始，从左到右依次递增
4. 获取序列中元素的方式：变量名[索引]
5. 从右开始索引时，索引值从 -1 开始，从右到左递减

#### 分片

1. 对序列中一定范围内的元素进行访问
2. 分片写法1：`序列[start:end]`，结果包含 start 位置的元素，不包括 end 位置的元素，即 $ start ≤ x < end $
3. 分片写法2：`序列[start:end:step]` 
4. start、end 可以为正数，也可以为负数，正数表示从左到右，负数表示从右到左
5. start 必须 **小于** end，否则结果将是空序列
6. 将 start 索引置为空，可以取到左边的头；end 置为空，可以取到右边的头；两边都为空，取整个序列
7. 步长设置为正数时，会从序列的头部开始向右提取元素；步长设置为负值时，则从尾部开始向左提取元素
8. 正数步长必须让开始点小于结束点，负数步长必须让开始点大于结束点

#### 相加

1. **类型相同的序列** 才能通过加号进行序列连接操作

#### 相乘

1. 一个序列乘以一个数字 x，会生成新的序列。在新的序列中，原来的序列将被重复 x 次
2. 小技巧：初始化一个长度为 x 的空序列
   1. None 是 Python 的内建值，确切的含义是：这里什么也没有
   2. `sq = [None] * 5 # 初始化 sq 为含有 5 个 None 的序列 `

#### 成员检查

1. in 可以很好地检测字符或数字是否在对应的列表中

2. 数字类型不能在字符串类型中通过 in 进行成员资格检测

3. 字符串类型可以在数字列表中通过 in 进行成员资格检测

   > 关于2、3的说明：
   >
   > ```python
   > number = [1,2,3,4,5,6,7,8,9]
   > print("a" in number)
   > # 输出结果 False
   > 
   > greeting = "hello"
   > print(3 in greeting)
   > # 运行后报错：
   > # TypeError: 'in <string>' requires string as left operand, not int
   > ```

#### 长度、最小值、最大值

1. 长度：`len(序列)`
2. 最小值：`min(序列或多个数字)`
3. 最大值：`max(序列或多个数字)`

### 列表

1. 内容是可变的
2. 通过：`列表[下标] = 值 `的方式对列表中的元素赋值
3. 一个列表可以存储类型不同的元素值
4. 增加元素：使用 append(obj) 方法，该方法会修改原来的列表，在原来列表的末尾添加新的对象
5. 删除元素：del 列表[序列]
6. 分片赋值：列表[start:end] = 新值，可用于字符替换、删除等

| 方法              | 作用                                                         |
| ----------------- | ------------------------------------------------------------ |
| append(obj)       | 在原来列表尾部添加新的对象                                   |
| count(obj)        | 统计某个元素在列表中出现的次数                               |
| extend(seq)       | 在列表尾部一次性追加另一个序列的多个值。注意：**修改了被扩展的序列** |
| index(obj)        | 从列表中找到某个值第一个匹配项的索引位置。注意：**如果搜索列表中不存在的字符串，操作结果就会出错** |
| insert(index,obj) | 将对象插入列表。参数：index——对象 obj 需要插入的索引位置；obj——要插入列表中的对象 |
| pop()             | 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 |
| remove(obj)       | 移除列表中某个值的第一个匹配项。注意：**如果移除列表中不存在的值，系统会告知移除的对象不在列表中** |
| reverse()         | 反向列表中的元素                                             |
| sort(func)        | 用于对原列表进行排序，如果指定参数，就是用参数指定的比较方法进行排序 |
| sorted(seq)       | 直接获取列表的副本进行排序                                   |
| clear()           | 清空列表，类似于 del a[:]                                    |
| copy()            | 复制列表                                                     |
| 高级排序          |                                                              |

### 元组

1. 元组的元素不能修改
2. 创建元组的方法：使用逗号分隔一些值，并用圆括号括起来
3. 创建包含一个值的元组：（1,），必须添加一个逗号
4. 访问元组：使用下标索引访问元组中的值，也可以分片访问
5. 修改元组：元组中的元素值不允许修改，但可以对元组进行连接组合（使用➕）
6. 删除元组：元组中的元素值不允许删除，但可以使用 del 语句删除整个元组
7. 索引、截取：元组是一个序列，可以访问元组中指定位置的元素，也可以截取索引中的一段元素

| 方法        | 作用                                                         |
| ----------- | ------------------------------------------------------------ |
| tuple(序列) | 以一个序列作为参数，并把它转化为元组；如果参数是元组，就被原样返回 |

### 字符串

1. 创建：使用 ' 或 "

2. 字符串是不可变的，不能做分片赋值

3. 字符串格式化：用操作符百分号 % 实现

   1. % 左边放置了一个待格式化的字符串，右边放置的是希望格式化的值（字符串或数字）
   2. 要输出 % 需要两个 %，即 %%

   | 符号 | 描述                           | 符号 | 描述                                |
   | ---- | ------------------------------ | ---- | ----------------------------------- |
   | %c   | 格式化字符串及其ASCII码        | %f   | 格式化浮点数字，可指定精度值        |
   | %s   | 格式化字符串                   | %e   | 用科学计数法格式化浮点数            |
   | %d   | 格式化整数                     | %E   | 作用同 e%，用科学计数法格式化浮点数 |
   | %u   | 格式化无符号整型               | %g   | %f 和 %e 的简写                     |
   | %o   | 格式化无符号八进制数           | %G   | %f 和 %E 的简写                     |
   | %x   | 格式化无符号十六进制数         | %p   | 用十六进制数格式化变量的地址        |
   | %X   | 格式化无符号十六进制数（大写） |      |                                     |

#### 格式化元组

格式化元祖时，元组中的每一个元素都会被单独格式化，每一个值都需要一个对应的转换说明符，例如：

```python
print('今年是%s年，中国女排夺得本届奥运会%s，中国共获得%d枚金牌' % ('2016','冠军',26))
# 以下是输出
今年是2016年，中国女排夺得本届奥运会冠军，中国共获得26枚金牌
```

> 序列中只有 **元组和字典** 可以格式化一个以上的值

##### 转换说明符

> 以下项的顺序很重要

1. % 字符：标记转换说明符开始
2. 转换标志（可选）：
   1. \- ：对齐
   2. \+ ：在转换值之前要加上正负号
   3. 空白字符：正数之前保留空格
   4. 0：转换值位数不够时用 0 填充
3. 最小字段宽度（可选）：转换后的字符串至少应该具有该值指定的宽度。如果是 *，宽度就会从值元组中读出
4. 点（.）后跟精度值（可选）：如果转换的是实数，精度值表示出现在小数点后的位数；如果转换的是字符串，该数字就表示最大字段宽度；如果是 *，精度就会从元组中读出

#### 字段宽度和精度

```python
print('圆周率 PI 的值为：%10f' % 3.141593) # 字段宽度为 10，字符占据 8 个宽度，剩余两个空格
print('保留 2 位小数，圆周率 PI 的值为：%10.2f' % 3.141593) # 字段宽度为 10，字符串占据 4 个，剩余 6 个
print('保留 2 位小数，圆周率 PI 的值为：%.2f' % 3.141593) # 没有字段宽度参数，直接输出 3.14
print('字符串精度获取：%.5s' % ('hello world')) # 打印字符串前 5 个字符
print('从元组中获取字符串精度：%*.*s' % (10, 5, 'hello world')) # 输出字符串宽度为 10，精度为 5
print('从元组中获取字符串精度：%.*s' % (5, 'hello world')) # 输出精度为 5

# 以下是输出
圆周率 PI 的值为：  3.141593
保留 2 位小数，圆周率 PI 的值为：      3.14
保留 2 位小数，圆周率 PI 的值为：3.14
字符串精度获取：hello
从元组中获取字符串精度：     hello
从元组中获取字符串精度：hello
```

#### 方法

| 方法                                | 作用                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| find(str,beg=0,end=len(string))     | 检查字符串 string 中是否包含子串 str<br />str：要搜索的子串，beg：开始索引，默认为0，end：结束索引，默认为字符串长度<br />如果找到，返回结果为子串所在位置的最左端索引；如果没有找到，返回 -1 |
| join(sequence)                      | 将序列中的元素以指定字符连接成一个新的字符串<br />进行 join 操作，调用和被调用对象必须都是字符串 |
| lower()                             | 将字符串中所有大写字符转换为小写                             |
| upper()                             | 将字符串中的小写字母转换为大写字母                           |
| swapcase()                          | 对字符串的大小写字母进行转换（大写变小写，小写变大写）       |
| replace(old, new[, max])            | 把字符串中的 old（旧字符串）替换为 new（新字符串），如果指定第 3 个参数 max，替换次数就不超过 max 次 |
| split(st='', num=string.count(str)) | 通过指定分隔符对字符串进行切片。<br />st : 分隔符，默认为空格；num : 代表分隔次数<br />返回：分割后的字符串列表 |
| translate(table[, deletechars])     | 根据参数 table 给出的表（包含 256 个字符）转换字符串的字符，将要过滤的字符放到 del 参数中 |



| 转义字符      | 描述       | 转义字符 | 描述                                     |
| ------------- | ---------- | -------- | ---------------------------------------- |
| \（在行尾时） | 续行符     | \n       | 换行                                     |
| \\\           | 反斜杠符号 | \v       | 纵向制表符                               |
| \\'           | 单引号     | \t       | 横向制表符                               |
| \\"           | 双引号     | \r       | 回车                                     |
| \a            | 响铃       | \f       | 换页                                     |
| \b            | 退格       | \oyy     | 八进制数，yy代表的字符，如\o12代表换行   |
| \e            | 转义       | \xyy     | 十六进制数，yy代表的字符，如\x0a代表换行 |
| \000          | 空         | \other   | 其他字符以普通格式输出                   |

### 字典

1. 字典由多个键及其对应的值构成的对组成（把键/值对称为项）字典的每个键/值对用冒号分隔，每个项之间用逗号分隔，整个字典包括在花括号里面：`{key1: value1, key2: value2}`

2. 空字典由两个大括号组成

3. 键是唯一的，并且必须是不可变的，如字符串、数字或元组；值可以取任何数据类型

4. 创建方式

   1. 通过字面量初始化

      ```python
      bob = {'name': 'Bob Smith', 'age': 42, 'pay': 30000, 'job': 'dev'}
      sue = {'name': 'Sue Jones', 'age': 45, 'pay': 40000, 'job': 'hdw'}
      ```

   2. 用 dict 函数，通过其他映射（如其他字典）、或键/值对序列对建立字典

      ```python
      student = [('name', '小萌'),('number', '1001')]
      detail = dict(student)
      print('学生详细信息：', detail)
      print('学生姓名：', detail['name'])
      print('学生学号：', detail['number'])
      
      # 下面是输出
      学生详细信息： {'name': '小萌', 'number': '1001'}
      学生姓名： 小萌
      学生学号： 1001
      ```

   3. 使用 dict 函数，通过关键字参数创建字典

      ```python
      detail = dict(name='小智', number='1002')
      print('学生详细信息：', detail)
      
      # 以下是输出
      学生详细信息： {'name': '小智', 'number': '1002'}
      ```

   4. 使用 zip 函数将名/值列表链在一起：

      ```python
      keys = ['name', 'age', 'pay', 'job']
      values = ['Bob Smith', 42, 30000, 'dev']
      zp = zip(keys, values)
      print(zp)
      lpbn = list(zp)
      print(lpbn)
      res = dict(list(lpbn))
      print(res)
      
      # 以下是输出
      <zip object at 0x102e7b550>
      [('name', 'Bob Smith'), ('age', 42), ('pay', 30000), ('job', 'dev')]
      {'name': 'Bob Smith', 'age': 42, 'pay': 30000, 'job': 'dev'}
      ```

   5. 通过一个键序列和所有键的可选值来创建字典（便于初始化空字典）：

      ```python
      keys = ['name', 'age', 'pay', 'job']
      # 注意：如果不输入 fromkeys 方法的第二个参数，key 的值将被初始化为 None
      ks = dict.fromkeys(keys, '?')
      print(ks)
      
      # 以下是输出
      {'name': '?', 'age': '?', 'pay': '?', 'job': '?'}
      ```

5. 修改字典：使用 `字典[键] = 值` 的方式，可以对字典进行修改和新增的操作
6. 删除字典元素：del 字典[键]
7. 删除整个字典：del 字典
8. 键的特点：
   1. 不允许同一个键出现两次。创建时如果同一个键被赋值两次，后面的值会被记住
   2. 键必须不可变，可以用数字、字符串或元组充当，不能用列表
9. len(dict)：用于计算字典元素的个数，即键的总数
10. type()：返回输入变量的变量类型

#### 格式化字符串

字典的格式化除了增加字符串键以外，转换说明符还像以前一样工作。以这种方式使用字典时，只要所有给出的键都能在字典中找到，就可以获得任意数量的转换说明符。

```python
student = {'小萌': '1001', '小智': '1002', '小强': '1003'}
print('小强的学号是：%(小强)s' % student)

# 以下是输出
小强的学号是：1003
```

> 注意：如果 % 后面是一个不存在的键，就会报：KeyError 的错误

| 方法                            | 说明                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| clear()                         | 删除字典内的所有项；返回值为 None                            |
| copy()                          | 返回一个具有相同键值对的新字典；返回结果为一个字典的浅复制<br />浅复制：替换副本的值时原始字典不受影响；修改某个值（原地修改，不是替换），原始字典就会改变，因为同样的值也在原字典中 |
| fromkeys(seq[, value])          | 创建一个新字典，以序列 seq 中的元素做字典的键，valie 为字典所有键对应的初始值；如果不传入 value 参数，新建字典中的每个 key 对应的值为 None |
| get(key[, default=None])        | 返回指定键的值。如果指定的键不在字典中，就返回默认值 None<br />注意：其他方法试图访问字典中不存在的项时会出错 |
| key in dict                     | 查找键是否在字典中                                           |
| items()                         | 返回可遍历的（键/值）列表，列表中的项是元组                  |
| keys()                          | 以列表的形式返回一个字典所有键                               |
| setdefault(key[, default=None]) | 用于获得与给定键相关联的值。当键存在时，返回与键对应的值；当键不存在时，返回默认值并使用默认只更新字典。 |
| update(dict)                    | 用于把字典 dict2 的键/值对更新到 dict 中。dict2 中的项会被添加到 dict 中，如果有相同的键就会被覆盖 |
| values()                        | 以列表形式返回字典中所有值                                   |

#### 判断字典中某个 key 是否存在

1. `key in dict.keys()`
2. `dict.get(key) == None`

### list 与 dict 的区别

dict 的特点：

1. 查找和插入的速度极快，不会随着 key 的增加而变慢
2. 需要占用大量内存，内存浪费极多

list 的特点：

1. 查找和插入时间随着元素的增加而增加
2. 占用空间小，浪费内存很少

所以，dict 是使用空间换取时间。

### Unicode 字符串

### buffer 对象

### xrange 对象

## 迭代器与生成器

1. 可以对迭代对象使用 iter() 方法来生成迭代器
2. 迭代器一定是迭代对象，迭代对象不一定是迭代器。

### 可迭代对象

如果一个对象实现了 `__iter__` 方法，这个对象就是可迭代对象。

可以直接作用于 for 循环的对象统称为可迭代对象：Iterable。例如列表等。

### 迭代器

可以使用 next() 方法进行回调的对象。

1. 可以记住遍历的位置的对象
2. 只能往前不会后退，没有办法获取迭代器的长度
3. 每调用一次 next() 方法，就会往下走一步，是惰性的
4. 提供一种不依赖索引取值的方式，这样可以遍历没有索引的可迭代对象，比如：字典、集合、文件等
5. 加载可迭代对象中的一个元素至内存中随后释放，这样相当的节省内存

#### 两个基本方法

##### iter()

从一个对象中获取迭代器。该方法有两种形式（这两种形式都返回 iterator）：

`iter(iterable)` ：该形式下，参数必须提供自己的迭代器，或者参数本身就是一个序列

`iter(callable, sentinel)` ：该形式下，可调用对象一直会被调用，直到返回一个标识

##### next()

`next(iterator[, default])` ：从迭代器中返回下一个元素。如果提供了 default 参数，并且迭代器执行完了，那么 next 就会返回 default 若指定的值，而不是抛出 StopIteration 这个异常。

#### 创建方法

如果对象本身有 `__iter__()` 方法，那它就是可以迭代的。

### 判断方法

1. 需要引入两个类：`form collections import Iterable, Iterator`
2. 使用 isinstance() 方法判断

### 小结

* 凡是可作用于 for 循环的对象都是 Iterable 类型
* 凡是可作用于 next() 函数的对象都是 Iterator 类型，他们表示一个惰性计算的序列
* 集合数据类型如 list、dict、str 等是 Iterable 但不是 Iterator，不过可以通过 iter() 函数获得一个 Iterator 对象

### 生成器

生成器（generator）：一边循环一边计算的机制。

生成器是一个特殊的程序，可以被用作控制循环的迭代行为，Python 中生成器是迭代器的一种，使用 `yield` 返回函数，每次调用 `yield` 会暂停，但可以使用 next() 函数和 send() 函数恢复生成器。

生成器类似于返回值为数组的一个函数，这个函数可以接受参数，可以被调用，但是，不同于一般的函数会一次性返回包括了所有数值的数组，生成器一次只能产生一个值，这样消耗的内存数量将大大减小，而且允许调用函数可以很快的处理前几个返回值，因此生成器看起来像是一个函数，但是表现的却像是迭代器。

#### 创建方法

##### 生成器表达式

 表达式返回一个对象，这个对象只有在需要的时候才产生结果。生成器表达式声明最简单的办法：把一个列表生成式的 [] 改为 () ，就创建了一个 generator：

```python
# 列表生成式
l = [x for x in range(10)]
print(l)

# 列表生成器
g = (x for x in range(10))
print(g)

# 转换方式
print(list(g))

# 以下是输出，可以看出：列表生成器是一个对象，直接打印会打印出该对象的地址，使用 list() 方法可以将一个生成器对象转换为列表
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
<generator object <genexpr> at 0x10e5f43d0>
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

##### 生成器函数

用 def 定义的，利用关键字 yield 一次性返回一个结果、阻塞、重新开始

#### 注意

创建生成器后，基本上永远不会对其调用 next() 方法，而是通过 for 循环来迭代它，并且不需要关心 StopIteration 的错误。

## 语句

### import 语句

#### 语法

```python
# 第一种方式
import module1[,module2[,...,moduleN]] # 从 Python 标准库中引入模块

# 第二种方式
from modname import name1[, name2[,...,nameN]] # 从模块中导入某个对象/函数到当前命名空间，不会导入整个模块，多个模块/函数之间用逗号分隔，导入所有使用 *

# 给模块、函数起别名
import module as alias
from math import pi as p
```

#### 说明

Python 解释器从 Python 的搜索路径（搜索路径由一系列目录名组成）中依次寻找引入的模块。可以通过定义环境变量的方式确定搜索路径。搜索路径是在 Python 编译或安装时确定的，被存储在 sys 模块的 path 变量中。查看搜索路径的方式如下：

```python
import sys

print('Python 的搜索路径为：%s' % sys.path)
```

#### 效率提升

1. 如果要使用 os 模块中的某个属性，那我们可以单独的引入这个属性

   `from os import version`

   同样的，我们也可以把引入的模块属性或者对象，直接赋值给另一变量，使用 as 方法：

   `from os import version as ver`

2. 如果在一个函数中频繁的使用某个模块的属性，那我们可以像上述那样，给它取一个本地变量的别名。因为频繁使用属性，而且模块是全局变量，这样消耗了多余的系统资源；并且，这样会使变量查找速度快很多；并且，便与记忆，便于书写

### 条件语句

#### 语法

```python
if 条件判断:
  语句块
elif 条件判断:
  语句块
else:
  语句块
```

#### 断言

在 Python 中，有一个和 if 语句工作方式非常相近的关键字：assert。

作用：当 assert 后面的条件为真时，程序正常运行；当 assert 后面的条件为假时，输出错误信息。

> 注意：
>
> 1. assert 断言用来声明某个条件是真的
> 2. 如果你非常确信你使用的列表中至少有一个元素，想要检验这一点，并在它非真时引发一个错误，那么 assert 语句是应用在这种情形下的理想语句
> 3. assert 语句失败时，会引发一个 AssertionError 错误

### 循环语句

#### while

##### 语法

```python
while 判断条件:
  执行语句
```

##### 执行过程

首先对 while 条件判定，当条件为 True 时，执行条件语句块，执行完语句块再判定 while 条件，若仍然为 True，则继续执行语句块，直到条件为 false 时结束循环。

#### for

##### 语法

```python
for iterating_var in sequence:
  statements(s)
  
# 说明：sequence 是任意序列，iterating_var 是序列中需要遍历的元素，statements 是待执行的语句块
```

##### 执行过程

首先对 for 条件判定，游标指向第 0 个位置，即指向第一个元素，看 sequence 序列中是否有元素，若有，则将元素值赋给 interating_var，接着执行语句块，若语句块中需要获取元素值，则使用 iterating_var 的值，执行完语句块后，将序列的游标往后挪一个位置，再判定该位置是否有元素，若仍然有元素，则继续执行语句块，然后序列的游标再往后挪一个位置，直到下一个位置没有元素时结束循环。

##### 循环遍历字典

 采用序列解包的方法：

```python
student = {'name': 'zhangsan', 'age': 14}
for key,value in student.items():
    print('%s : %s' % (key, value))
    
# 以下是输出
name : zhangsan
age : 14
```

> Python 中循环特有的现象：
>
> 1. 当循环结束以后，循环体中的临时变量不会销毁，而是继续存在于执行环境中
> 2. 函数只有在执行时，才会去找函数体里变量的值

### 迭代

#### 并行迭代

```python
student = ['小明', '小智', '小强']
number = [1001, 1002, 1003]
for i in range(len(student)):
    print('学生：%s 的编号是：%d' % (student[i], number[i]))

# 以下是输出
学生：小明 的编号是：1001
学生：小智 的编号是：1002
学生：小强 的编号是：1003

for name,num in zip(student, number):
    print(name, '的学号是：', num)
    
# 第二个的输出与第一个的输出一样

for n1,n2 in zip(range(3), range(100)):
    print('num1: ', n1, 'num2: ', n2)
    
# 以下是输出
num1:  0 num2:  0
num1:  1 num2:  1
num1:  2 num2:  2
```

##### zip 函数

1. 内建的 zip 函数用来进行并行迭代，可以把两个序列合并在一起，返回一个元组的列表
2. 当用于合并的两个序列长度不一时，以短序列为准，当短序列遍历结束时，for 循环就会遍历结束

#### 翻转和排序迭代

反转迭代：reversed()，返回的是一个可迭代对象；

排序迭代：sorted()，返回的是一个列表。

这两个函数可作用于任何序列活可迭代对象，但不是原地修改对象，而是返回翻转或排序后的版本。

```python
n_list = [5, 3, 7, 1]
print(sorted(n_list))
strings = 'hello,world!'
print(sorted(strings))
print(list(reversed(strings)))
print(''.join(reversed(strings)))

# 以下是输出
[1, 3, 5, 7]
['!', ',', 'd', 'e', 'h', 'l', 'l', 'l', 'o', 'o', 'r', 'w']
['!', 'd', 'l', 'r', 'o', 'w', ',', 'o', 'l', 'l', 'e', 'h']
!dlrow,olleh
```

#### 跳出循环

##### break

终止循环语句

##### continue

跳过当前循环的剩余语句

#### else 子句

1. 用在 while 和 for 循环中
2. 在 while 条件语句为 False 时，执行 else 的语句块
3. 在 for 条件语句为 False 或结束后没有被 break 中断时，执行 else 的语句块

#### pass 语句

pass 是空语句，作用是保持程序结构的完整性，即不作任何事情，只是占位语句。

### with 语句

#### 适用场景

适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的清理操作，释放资源。比如，文件使用后自动关闭、现成中锁的自动获取和释放、数据库操作后自动释放等等。

#### 上下文管理器

它是 Python 中的一种协议。实现了这种协议的类的实例，都是上下文管理器。

with 使用了上下文管理器，可以自动获取上下文相关内容，让开发者更专注于业务。

##### 创建上下文管理器

在类定义的时候，实现两个方法就可以：enter()、exit()

```python
# 方法一：实现 enter()、exit() 两个方法
class A():
    def __init__(self, val_a):
        self.a = val_a

    def __enter__(self):
        print("class A‘s __enter__ function.’")

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("class A's __exit__ function.")
        
# 方法二：使用装饰器 @contentmanager

from contextlib import contextmanager

@contextmanager
def demo_func():
    print("enter")
    yield "demo_func"
    print("exit")
```

上面的例子中，可以使用两种方式创建实现上下文管理协议的对象

### 其它语句

## 函数

### 定义函数

1. 函数代码块以 def 关键字开头，后接函数标识符名称和圆括号
2. 所有传入的参数和自变量都必须放在圆括号内，可以在圆括号内定义参数
3. 函数名必须以字母开头，可以包含下划线
4. 函数的第一行语句可以选择性使用文档字符串，用于存放函数说明
5. 函数内容以冒号开始，并且要求缩进，函数体必须保持一致的缩进
6. return [表达式] 结束函数，选择性返回一个值给调用方。不带表达式的 return 相当于返回 None

```python
def 函数名(参数列表):
  函数体

# 或者更直观的表示为

def<name>(arg1,arg2,...,argN):
  <statements>
```

### 参数

#### 关键字参数

函数调用时，如果将参数名和参数值一起传入，调用时的参数顺序就不需要与函数定义使得参数顺序一致；如果只传值，不传名，就需要一致。

```python
def personinfo(age, name):
    print('年龄：', age)
    print('姓名：', name)
    return

# 不传参数名称，按定义时的顺序调用
personinfo(13, '小萌')

# 传入参数名称，参数顺序随便写
personinfo(name='小萌', age=13)
```

#### 默认参数

默认参数，也就是在定义函数时，给参数一个默认值。

必须参数，也就是在定义函数时，没有默认值的参数。

默认参数的使用要注意以下几点：

1. 无论有多少默认参数，默认参数都不能在必需参数之前
2. 无论有多少默认参数，若不传入默认参数值，则使用默认值
3. 若要更改某一个默认参数值，又不想传入其他默认参数，且该默认参数的位置不是第一个，则可以通过参数名更改想要更改的默认参数值
4. 若有一个默认参数通过传入参数名更改参数值，则其他想要更改的默认参数都需要传入参数名更改参数值，否则报错
5. 更改默认参数值时，传入默认参数的顺序不需要根据定义的函数中的默认参数的顺序传入，不过最好同时传入参数名，否则容易出现执行结果与预期不一致的情况

#### 可变参数

如果一个参数能够处理的参数比声明时的参数数量多，那就需要可变参数。语法如下：

```python
def functionname([formal_args,]*var_args_tuple):
  return [expression]
```

加了星号（*）的变量名会存放所有未命名的变量参数。如果变量参数在函数调用时没有指定参数，就是一个空元组。

使用 ** 处理关键字参数，可以获得一个字典。这里的字典是对实际参数的复制，也就是说对形式参数字典的改变不会影响实际参数字典的值。

> 注意：定义参数的顺序 **必须是：必须参数、默认参数、可变参数、关键字参数**

### 变量

要在函数体中将某个变量定义为全局变量，在需要被定义的变量前加一个关键字 global 即可。

### 闭包

第一种解释：

如果在一个内部函数里对外部函数（不是在全局作用域）的变量进行引用，内部函数就被认为是闭包。

第二种解释：

提前说明：如果在一个函数的内部定义了另一个函数，外部的我们叫他外函数，内部的我们叫他内函数。

在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。

#### 要点

按照我们正常的认知，一个函数结束的时候，对把自己的临时变量都释放还给内存，之后变量都不存在了。一般情况下，确实是这样的。但是闭包是一个特殊的情况。外部函数发现，自己的临时变量会在将来的内部函数中用到，自己在结束的时候，返回内函数的同时，会把外部的临时变量送给内函数绑定在一起。所以外函数已经结束了，调用内函数的时候仍然能够使用外函数的临时变量。

#### 闭包中内函数修改外函数的局部变量

有两种方法：

1. 的 Python 3 中，用 nonlocal 关键字声明一个变量，表示这个变量不是局部变量空间的变量，需要向上一层变量空间找这个变量
2. 的 Python 2 中，把变量改成可变类型数据进行修改，比如列表

#### 需要注意的

1. 使用闭包的过程中，一旦外函数被调用一次返回了内函数的引用，虽然每次调用内函数，是开启一个函数执行过后消亡，但是闭包变量实际上只有一份，每次开启内函数都在使用同一份闭包变量。

   ```python
   def outer(x):
       def inner(y):
           nonlocal x
           x += y
           return x
       return inner
   
   a = outer(10)
   print(a(1)) # 这一句执行完成后，外函数 x 的值已经变为 11 了
   print(a(3))
   
   # 以下是输出
   11
   14
   ```

### 匿名函数

不再使用 def 语句这样的标准形式定义一个函数。

#### 创建方式

使用 lambda 创建匿名函数。

#### 规则

1. 一般有一行表达式，必须有返回值
2. 不能有 return
3. 可以没有参数，也可以有一个或多个参数
4. 参数中允许参数有默认值
5. lambda 函数拥有自己的命名空间，不能访问自有参数列表之外或全局命名空间的参数

#### 语法

```python
lambda [arg1[,arg2,...,argn]]:expression
```

#### 说明

lambda 一般用于函数式编程，代码简洁，常和 filter 等函数结合使用。

#### 适合使用匿名函数的情况

1. 程序一次性使用、不需要定义函数名时，用匿名函数可以节省内存中变量定义空间

### 偏函数

#### 定义

将所要承载的函数作为 functools.partial() 函数的第一个参数，原函数的各个参数依次作为 partial() 函数的后续参数，除非使用关键字参数。

#### 实例

```python
from functools import partial

twoToTen = partial(int, base=2)
print(twoToTen('10010101'))

def add(x, y, z):
    return x + y + z

addNums = partial(add, 10, 20)
print(addNums(30))
addNums1 = partial(add, 5)
print(addNums1(10, 15))
print(addNums1(z=4, y=3))

# 以下是输出
149
60
30
12
```

### 函数出错调试时的技巧

1. 函数获得的实参有问题，某个前置条件没有达到
2. 函数本身有问题，某个后置条件没有达到
3. 函数的返回值有问题或使用方式不对

## 面向对象

每个对象都有各自的编号、类型和值。一个对象被创建后，它的编号就绝不会改变；可以将其理解为该对象在内存中的地址。`is` 运算符可以比近两个对象的编号是否相等；`id()` 函数能返回一个代表其编号的整形数，也就是说，`id(x)` 就是存放 x 的内存地址。

有些对象包含对其他对象的引用，它们被称为容器。容器的例子有：元组、列表、字典等。

### 术语

#### 类

用来描述具有相同属性和方法的对象的集合。类定义了集合中每个对象共有的属性和方法。对象是类的实例。

#### 类变量（属性）

类变量在整个实例化的对象中是公用的。类变量定义在类中，且在方法之外。类变量通常不作为实例变量使用。类变量也称作属性。

#### 数据成员

类变量或实例变量用于处理类及其实例对象的相关数据。

#### 方法重写

如果从父类继承的方法不能满足子类的需求，就可以对其进行改写，这个过程称之为方法的覆盖（Override），也称为方法的重写。

#### 实例变量

定义在方法中的变量只作用于当前实例的类。

#### 多态

对不同类的对象使用同样的操作。

#### 封装

对外部世界隐藏对象的工作细节。

#### 继承

即一个派生类继承基类的字段和方法。继承允许把一个派生类的对象作为一个基类对象对待，以普通类为基础建立专门的类对象。

#### 实例化

创建一个类的实例、类的具体对象。

#### 方法

类中定义的函数。

#### 对象

通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。

### 类定义

```python
class ClassName(object):
  '类的帮助信息'  # 该信息可以通过 ClassName.__doc__ 查看
  <statement-1>
  .
  .
  .
  <statement-n>
```

### 类的使用

```python
use_class = MyClass() # 类的实例化
print(use_class.i) # 打印类的变量，即类变量
print(use_class.f()) # 调用类的方法
```

#### 类变量

类变量可以在内部类外部类使用 `ClassName.类变量` 或者 `类的实例.变量名` 进行访问。

和静态语言不同，Python 允许对实例变量绑定任何数据，也就是说，虽然他们都是同一个类的不同实例，但拥有的变量名称都可能不同。

```python
class MyClass():
    a = 10
    def haha(self):
        pass

myClass = MyClass()
myClass.a = 20
myClass.b = 30
print(myClass.a, '，', myClass.b)

anotherClass = MyClass()
print(anotherClass.b)

# 以下是输出
20 ， 30
Traceback (most recent call last):
  File "/Users/***/project/vscode/python-start/circle.py", line 535, in <module>
    print(anotherClass.b)
AttributeError: 'MyClass' object has no attribute 'b'
```

#### 类变量与实例变量

当使用 `实例名.变量名` 的方式访问变量时，实例会首先在自己的实例变量中查找是否有此实例变量，然后再去类变量中进行查找，如果都没有，则抛出异常。

```python
class Student(object):
    classroom = '101'
    address = 'beijing'
    def __init__(self, name, age):
        self.name, self.age = name, age

    def printInfo(self):
        print('name:{}'.format(self.name), 'age:{}'.format(self.age))

stu1 = Student('小明', 23)
stu2 = Student('小李', 22)
print(stu1.classroom) # 打印时发现，stu1 本身没有名为 classroom 的实例变量，就去类里找实例变量，找到了，就打印出来了
print(Student.classroom)
stu1.classroom = '110'
print(stu1.classroom) # 上面的操作已经给 stu1 这个实例创建了一个名为 classname 的实例变量，所以这里打印的是上一行赋的值
print(Student.classroom)
print(stu2.classroom)

# 以下是输出
101
101
110
101
101
```

#### 实例方法

类的实例方法由类的实例调用，至少包含一个 self 参数，且为第一个参数。执行实例方法时，自动将调用该方法的实例赋值给 self。self 代表创建的类的实例本身，而非类本身，self.__class\_\_ 指向类。并且，self 不是关键字，而是 Python 约定成俗的命名，完全可以使用别的名字，但是不建议这样做。

#### 静态方法

静态方法由类调用，无默认参数。将实例方法中的 self 参数去掉，然后在方法定义上方加上 @staticmethod，就成为静态方法，它属于类，和实例无关。建议只使用：`类名.静态方法名` 的方式调用

```python
class Foo:
    @staticmethod
    def static_method():
        print('我是一个静态方法')

Foo.static_method()
```

#### 类方法

类方法由类调用，采用 @classmethod 装饰，至少传入一个 cls（代指类本身，类似 self）参数。

#### 调用类方法的要求

要调用类的一个方法，在类的实例变量上直接调用即可。除了 self 参数不用传递，其他参数正常传入。

self 代表创建的类的实例本身，self.\__class__ 指向类。

### 构造方法

` __init__() `

在定义类时，若不显式定义一个 `__init__()` 方法，则程序默认调用一个无参的 `__init__()` 方法。

一个类可以有多个构造方法，那个构造方法在后面出现，哪个构造方法生效。

### 类的访问权限

1. 在类内部有属性和方法，外部代码可以通过直接调用实例变量的方法操作数据，这样就隐藏了内部的复杂逻辑。
2. 在类中定义的非构造方法可以调用类中构造方法实例变量的属性，调用的方式为 `self.实例变量属性名` ，在类的外部也可以对这些实例变量属性名进行修改，调用的方法是：`类的实例变量.实例变量属性名` 
3. 要让内部属性不被外部访问，可以在属性名称前加两个下划线。的 Python 中，实例的变量名如果以 __ 开头，就会变成私有变量，只有内部可以访问，外部不能访问
   1. 不能直接访问 __variable 是因为 Python 届时其对外把 \_\_variable 变量改成了 _ClassName\_\_variable，所以仍然能够通过 _ClassName\_\_variable 访问 \_\_variable 变量
4. 可以为类增加 get_attrs 方法，用于获取类中的私有变量
5. 可以为类增加 set_attrs 方法，用于修改类中的私有变量
6. 类的方法也可以是私有的。以两个下划线开头的方法就是类的私有方法，不能在类外使用

### 继承

1. 当我们定义一个 class 时，可以从某个现有的 class 继承，定义的新 class 称为子类，而被继承的 class 称为基类、父类或超类

2. Python 支持多重继承，在函数的圆括号内写上以逗号分隔的多个父类即可

   > 要注意圆括号中父类的顺序：
   >
   > 1. 若父类中有相同的方法名，在子类使用时未指定，Python 会从左到右搜索
   > 2. 若方法在子类中未找到，则从左到右查找父类中是否包含方法

#### 语法

```python
class DerivedClassName(BbaseClassName):
  '类的帮助信息'
  <statement-1>
  .
  .
  .
  <statement-N>
```

#### 特点

1. 在继承中，基类的构造方法不会被自动调用，需要在子类的构造方法中专门调用
2. 在调用基类的方法时需要加上基类的类名前缀，并带上 self 参数变量。区别在于类中调用普通函数时不需要带 self 参数
3. 在 Python 中，首先查找对应类型的方法，如果在子类中找不到对应的方法，才到基类中逐个查找
4. 继承的最大好处是：子类获得了父类全部非私有的功能

### 多态

当子类和父类存在相同的方法时，子类的方法会覆盖父类的同名方法，在代码运行时总是会调用子类的方法，这称之为多态。

### 封装

封装是全局作用域中其他区域隐藏多余信息的原则。也可以说是对外屏蔽内部的实现。

### 属性访问

`__get__()`、`__getattr__()`、`__getattribute__()` 都是类访问属性的方法，但不太相同。

#### `object.__getattr__(self,name)`

当一般位置找不到 attribute 的时候，就会调用 getattr，返回一个值或 AttributeError 异常。

#### `object.__getattribute__(self, name)`

无条件被调用，通过实例访问属性。如果类中定义了 `__getattr__()` ，则  `__getattr__()` 不会被调用，除非显式调用或引发 AttributeError 异常。

#### `object.__get__(self, name, owner)`

只用在 descriptor （实现了 `__get__` 的类）中，可以通过 owner class 或者 indtance 来访问属性。

```python
class C(object):
    a = 'abc'
    def __getattribute__(self, *args, **kwargs):
        print('__getattribute__() is called')
        return object.__getattribute__(self, *args, **kwargs)
    
    def __getattr__(self, name):
        print('__getattr__() is called')
        return name + ' from getattr'
    
    def __get__(self, instance, owner):
        print('__get__() is called', instance, owner)
        return self
    
    def foo(self, x):
        print(x)

class C2(object):
    d = C()

c = C() 
c2 = C2() 
print(c.a)
print(c.zzzzzzzz)
c2.d
print(c2.d.a)

# 以下是输出
__getattribute__() is called
abc
__getattribute__() is called
__getattr__() is called
zzzzzzzz from getattr
__get__() is called <__main__.C2 object at 0x1059f30d0> <class '__main__.C2'>
__get__() is called <__main__.C2 object at 0x1059f30d0> <class '__main__.C2'>
__getattribute__() is called
abc
```

#### 小结

可以看出，每次通过实例访问属性，都会经过__getattribute__函数。而当属性不存在时，仍然需要访问__getattribute__，不过接着要访问__getattr__。这就好像是一个异常处理函数。

每次访问descriptor（即实现了__get__的类），都会先经过__get__函数。

需要注意的是，当使用类访问不存在的变量是，不会经过__getattr__函数。而descriptor不存在此问题，只是把instance标识为none而已。

### 获取对象信息

#### 获取对象的方法r

##### type() 函数

基本类型都可以用 type() 函数判断，例如：

```python
print(type(123))
print(type('abc'))
print(type(None))
print(type(abs))

# 以下是输出
<class 'int'>
<class 'str'>
<class 'NoneType'>
<class 'builtin_function_or_method'>
```

比较两个变量的 type 类型是否相等：

```python
import types

print(type(123) == type(456))
print(type(123) == int)
print(type('abc') == type('123'))
print(type('abc') == str)
print(type('abc') == type(123))
def fn():
    pass
print(type(fn) == types.FunctionType)
print(type(abs) == types.BuiltinFunctionType)
print(type(lambda x: x > 0) == types.LambdaType)
print(type((x for x in range(10))) == types.GeneratorType)

# 以下是输出
True
True
True
True
False
True
True
True
True
```

##### isinstance() 函数

用于判断一个对象是否是某个类型，例如：

```python
print(isinstance(123, (float)))
print(isinstance(123, (int, float)))

# 以下是输出
False
True
```

#### dir() 函数

如果要获得一个对象的所有属性和方法，就可以使用 dir() 函数。dir() 函数返回一个字符串的 list，例如：

```python
print(dir(list))

# 以下是输出
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
```

### 专有方法

专有方法是在特殊情况下使用或使用特别语法时由 Python 调用的，而不是像普通方法一样在代码中直接调用。

#### `__str__()`

返回用户看到的字符串，即对一般的类成员变量进行格式化输出。

#### `__repr__()`

返回程序开发者看到的字符串，是为调试服务的。可以对输出的对象进行格式化输出。

#### `__iter__()`

如果想将一个类用于 for...in 循环，类似 list 或 tuple 一样，就必须实现一个 `__iter__()` 方法。该方法返回一个迭代对象，Python 的 for 循环会不断调用该迭代对象的 `__next__()` 方法，获得循环的下一个值，直到遇到 StopIteration 错误时退出循环。

```python
class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器
    
    def __iter__(self):
        return self  # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a > 100000: # 退出循环条件
            raise StopIteration()
        return self.a # 返回下一个值

for n in Fib():
    print(n)
    
# 以下是输出
1
1
2
3
5
8
13
21
34
55
89
144
233
377
610
987
1597
2584
4181
6765
10946
17711
28657
46368
75025
```

#### `__call()__`

任何类，只需要定义一个 `__call__()` 方法，就可以直接对实力进行调用：

```python
class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print('名称：%s' % self.name)

stu = Student('小明')
stu()

# 以下是输出
名称：小明
```

## 异常

异常是一个事件，该事件会在程序执行过程中发生，影响程序的正常运行。一般情况下，在 Python 无法正常处理程序时就会发生异常。异常是 Python 的对象，表示一个错误。当 Python 脚本发生异常时，我们需要捕获并处理异常，否则程序会终止执行。

### 捕获异常语法

```python
try:
  <语句>  # 运行别的代码
except <名字>:
  <语句>  # 如果在 try 部分发生了异常
```

### try 的工作原理

开始一个 try 语句后，Python 就在当前程序的上下文中做标记，当出现异常时就可以回到做标记的地方。

如果 try 后的语句在执行时发生异常，程序就跳回 try 并执行 except 子句。

异常处理完毕,控制流就可以通过整个 try 语句了（除非在处理异常时又引发新异常）。

```python
def exp(x, y):
    try:
        a = x / y
        print('a=', a)
        return a
    except Exception:
        print('程序出现异常，异常信息：被除数为 0')

exp(2, 0)

# 以下是输出
程序出现异常，异常信息：被除数为 0
```

> 如果没有处理异常，异常就会被“传播”到调用的函数中。如果在调用的函数中依然没有处理，异常就会继续传播，直到程序的最顶层。也就是可以处理其他人程序中未处理的异常。

### 抛出异常

Python 使用 raise 异常抛出一个指定异常。我们可以使用类（Exception 的子类）或实例参数调用 raise 语句引发异常。使用类时程序会自动创建实例。

如果只是想知道是否抛出了异常，并不想处理，使用一个简单的 raise 语句就可以再次把异常抛出。

```python
class Exp(object):
    def handExp(self): # 手动抛出异常
        raise Exception
    def handleExp(self): # 手动处理异常
        try:
            raise NameError('这是 NameError')
        except NameError:
            print('发生了异常')
    def throwExp(self): # 抛出异常
        try:
            raise NameError('这是 NameError')
        except NameError:
            print('发生了异常，但是我不处理，谁爱处理去处理！')
            raise

exp = Exp()
exp.handExp()
exp.handleExp()
exp.throwExp()

# 以下是输出及说明
# 当执行 exp.handExp() 这句时，因为只是手动抛出异常，没有处理，所以中断了整个程序的执行，后面的语句无法执行，输出如下
Traceback (most recent call last):
  File "/Users/***/project/vscode/python-start/circle.py", line 593, in <module>
    exp.handExp()
  File "/Users/***/project/vscode/python-start/circle.py", line 579, in handExp
    raise Exception
Exception
# 把 exp.handExp() 这句注释掉，后面的程序就可以正常运行了，输出如下
发生了异常
发生了异常，但是我不处理，谁爱处理去处理！
Traceback (most recent call last):
  File "/Users/***/project/vscode/python-start/circle.py", line 595, in <module>
    exp.throwExp()
  File "/Users/***/project/vscode/python-start/circle.py", line 587, in throwExp
    raise NameError('这是 NameError')
NameError: 这是 NameError
```

### 捕获多个异常

```python
# 第一种写法
try:
  <语句> # 运行别的代码
except <名字1>:
  <语句> # 如果在 try 部分引发了 名字1 异常
except <名字2>:
  <语句> # 如果在 try 部分引发了 名字2 异常，获得附加数据
  
# 第二种写法
try:
  <语句> # 运行别的代码
except(名字1,名字2,...):
  <语句> # 如果异常是上面元组里的任意一个，则执行该语句
```

### Python 重要的内建异常类

| 异常名称       | 描述                          |
| -------------- | ----------------------------- |
| Exception      | 常规错误的基类                |
| AttributeError | 对象没有这个属性              |
| IOError        | 输入/输出操作失败             |
| IndexError     | 序列中没有此索引              |
| KeyError       | 映射中没有这个键              |
| NameError      | 未声明/初始化对象（没有属性） |
| SyntaxError    | Python 语法错误               |
| SystemError    | 一般解释器系统错误            |
| ValueError     | 传入无效的参数                |

### 捕捉对象

如果希望在 except 子句中访问异常对象本身，也就是看到一个异常对象真正的异常信息，而不是输出自己定义的异常信息，可以使用 as e 的形式，这称之为捕获对象：

```python
def exp(x, y):
    try:
        a = x / y
        print('a=', a)
        return a
    except (ZeroDivisionError, NameError, TypeError) as e:
        print(e)

exp(2, 0)

# 以下是输出
division by zero
```

### 全捕捉

except 后面什么都不写，就可以在 except 子句中忽略所有异常类，从而让程序输出自己定义的异常信息。

从实用性方面讲，不建议这么做，因为这样捕捉异常非常危险，会隐藏所有没有预先想到的错误。

建议使用抛出异常的方式处理，或者对异常对象 e 进行一些检查。

### 异常中的 else

语法：

```python
try:
  <语句>
except <名字>:
  <语句>
else:
  <语句> # 如果没有发生异常
```

通过添加一个 else 子句做一些事情（比如输出一些信息）很有用，可以帮助我们更好的判断程序的执行情况。

### 自定义异常

自定义异常应该继承 Exception 类，可以直接继承，也可以间接继承。

自定义异常类也可以抛出错误，根据需要定义一个错误的类，选择好继承关系，然后用 raise 语句抛出一个错误的实例。

```python
class MyError(Exception):
    def __init__(self):
        pass
    def __str__(self):
        return '这是自定义的错误类型'

def error_test():
    try:
        raise MyError()
    except MyError as e:
        print('异常信息：', e)

error_test()

# 以下是输出
异常信息： 这是自定义的错误类型
```

### finally 子句

Python 中的 finally 子句需要和 try 子句一起使用。无论是否发生错误，finally 子句中的程序必定会执行。

```python
try:
  <语句>
except <名字>:
  <语句>
else:
  <语句>
finally:
  <语句>
```

## 时期和时间

### 时间戳

通常，时间戳（timestamp）表示从 1970 年 1 月 1 日 00 时 00 分 00 秒开始按秒计算的偏移量，也就是从1970 年 1 月 1 日 00 时 00 分 00 秒起到现在的总毫秒数。

时间戳是一个经加密后形成的凭证文档，包括 3 部分：

1. 需要加时间戳的文件的摘要（digest）
2. DTS 收到文件的日期和时间
3. DTS 的数字签名

> Python 3 中支持的最大时间戳为 32535244799（3001-01-01 15：59：59）

### 时间格式化符号

| 格式 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| %a   | 本地简化星期名称                                             |
| %A   | 本地完整星期名称                                             |
| %b   | 本地简化月份名称                                             |
| %B   | 本地完整月份名称                                             |
| %c   | 本地相应的日期和时间表示                                     |
| %d   | 一个月中的第几天（01~31）                                    |
| %H   | 一天中的第几个小时（24小时制，00~23）                        |
| %I   | 第几个小时（12小时制，01~12），与 %p 配合使用才有效果        |
| %j   | 一年中的第几天（001~366）                                    |
| %m   | 月份（01~12）                                                |
| %M   | 分钟数（00~59）                                              |
| %p   | 本地 AM 或 PM 的相应符，与 %I 配合使用才有效果               |
| %S   | 秒（01~61），因为闰年占两秒                                  |
| %U   | 一年中的星期数（取值00~53，星期天为一星期的开始），第一个星期天之前的所有天数都放在第0周 |
| %w   | 一个星期中的第几天（0~6，0 是星期天）。当使用 strptime() 函数时，只有这一年的周数和天数确定时 %U 和 %W 才会被计算 |
| %W   | 和 %U 基本相同，不同的是 %W 以星期一为一个星期的开始         |
| %x   | 本地相应日期                                                 |
| %X   | 本地响应时间                                                 |
| %y   | 去掉世纪的年份（00~99）                                      |
| %Y   | 完整的年份                                                   |
| %Z   | 时区的名字（如果不存在为空字符）                             |
| %%   | %字符                                                        |

### struct_time 元组

struct_time 元组共有 9 个元素：年、月、日、时、分、秒、一年中第几周、一年中第几天、是否为夏令时。

Python 函数用一个元组装起来的 9 组数字处理时间，也被称作 struct_time 元组，下表是这种结构的属性：

| 序号 | 属性     | 字段         | 值                                    |
| ---- | -------- | ------------ | ------------------------------------- |
| 0    | tm_year  | 4 位数字     | 如2008                                |
| 1    | tm_mon   | 月           | 1~12                                  |
| 2    | tm_mday  | 日           | 1~31                                  |
| 3    | tm_hour  | 小时         | 0~23                                  |
| 4    | tm_min   | 分钟         | 0~59                                  |
| 5    | tm_sec   | 秒           | 0~61（60或61，61是闰年）              |
| 6    | tm_wday  | 一周的第几日 | 0~6（0 是周一）                       |
| 7    | tm_yday  | 一年的第几日 | 1~366                                 |
| 8    | tm_isdst | 夏令时       | -1、0、1、-1 是决定是否为夏令时的旗帜 |

### time 模块

| 语法                      | 作用                                                         | 注意                                                         |
| ------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| time.time()               | 返回当前时间的时间戳                                         | 返回的时间戳是带小数点的                                     |
| localtime([secs])         | 格式化时间戳为本地时间                                       | secs 参数指转换为 time.stuct_time 类型的对象的秒数           |
| gmtime([secs])            | 将一个时间戳转换为 UTC 时区（0时区）的 struct_time           | secs 参数表示从 1970-1-1 到现在的秒数<br />函数的默认值为 time.time()<br />函数返回 time.struct_time 类型的对象 |
| mktime(t)                 | 接受 struct_time 对象作为参数，返回用秒数表示时间的浮点数    | 该函数用于执行与 gmtime()、localtime() 相反的操作<br />参数 t 值结构化的时间或完整的 9 位元组元素 |
| asctime([t])              | 接收时间元组并返回一个可读的形式为 Sun Sep 25 09:09:37 2016 的24个字符的字符串 | 参数 t 指完整的 9 位元组或通过函数 gmtime()、localtime() 返回的时间值 |
| ctime([secs])             | 用于把一个时间戳（按秒计算的浮点数）转化为 time.asctime() 的形式 | 如果未指定参数 secs 或参数位 None，就会默认将 time.time() 作为参数。<br />该函数的作用相当于 asctime(localtime(secs)) |
| sleep(secs)               | 用于推迟调用线程的运行，可通过参数 secs  指定进程挂起的时间  | secs 指推迟执行的秒数                                        |
| clock()                   | 用于以浮点数计算的秒数返回当前 CPU 时间，用来衡量不同程序的耗时，比 time.time() 更有用 | 该函数在不同系统上含义不同。<br />在 UNIX 系统上，返回的是“进程时间”，是用秒表示的浮点数（时间戳）<br />在 Windows 中，第一次调用返回的是进程运行的实际时间，第二次之后的调用是自第一次调用后到现在的运行时间<br />**该函数自 Python 3.3 开始被声明为过时** |
| strftime(format[,t])      | 用于接收时间元组，并返回可读字符串表示的当地时间，格式由参数 format 决定 | format——格式化字符串，t——是一个struct_time对象               |
| strptime(string[,format]) | 用于根据指定的格式把一个时间字符串解析为时间元组             | string——时间字符串，format——格式化字符串                     |

```python
import time

print(time.time())
print('time.localtime()：', time.localtime())
print('time.gmtime()：', time.gmtime())
t = (2016, 9, 25, 17, 35, 38, 6, 48, 0)
print('time.mktime(t)：%f' % time.mktime(t))
tt = time.localtime()
print('time.asctime(t)：%s' % time.asctime(tt))
print('time.ctime()：%s' % time.ctime())
print('Start: %s' % time.ctime())
time.sleep(5)
print('End: %s' % time.ctime())

def procedure():
    time.sleep(2)

# mesure process time
t1 = time.clock()
procedure()
print('seconds process time: ', time.clock() - t1)

# measure wall time
t2 = time.time()
procedure()
print('seconds wall time: ', time.time() - t2)

ttt = (2016, 9, 25, 17, 50, 38, 6, 48, 0)
ttt = time.mktime(ttt)
print(time.strftime('%b %d %Y %H:%M:%S', time.gmtime(ttt)))

struct_time = time.strptime('25 Sep 16', '%d %b %y')
print('returned tuple: ', struct_time)

# 以下是输出
1569676535.921487
time.localtime()： time.struct_time(tm_year=2019, tm_mon=9, tm_mday=28, tm_hour=21, tm_min=15, tm_sec=35, tm_wday=5, tm_yday=271, tm_isdst=0)
time.gmtime()： time.struct_time(tm_year=2019, tm_mon=9, tm_mday=28, tm_hour=13, tm_min=15, tm_sec=35, tm_wday=5, tm_yday=271, tm_isdst=0)
time.mktime(t)：1474796138.000000
time.asctime(t)：Sat Sep 28 21:15:35 2019
time.ctime()：Sat Sep 28 21:15:35 2019
Start: Sat Sep 28 21:15:35 2019   # 在这里线程停止 5 秒
End: Sat Sep 28 21:15:40 2019
/Users/wchya/project/vscode/python-start/circle.py:629: DeprecationWarning: time.clock has been deprecated in Python 3.3 and will be removed from Python 3.8: use time.perf_counter or time.process_time instead
  t1 = time.clock()
/Users/wchya/project/vscode/python-start/circle.py:631: DeprecationWarning: time.clock has been deprecated in Python 3.3 and will be removed from Python 3.8: use time.perf_counter or time.process_time instead
  print('seconds process time: ', time.clock() - t1)
seconds process time:  0.000500999999999998
seconds wall time:  2.0046770572662354
Sep 25 2016 09:50:38
returned tuple:  time.struct_time(tm_year=2016, tm_mon=9, tm_mday=25, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=6, tm_yday=269, tm_isdst=-1)
```

#### 三种时间格式转化

![image-20190928212604438](/Users/wchya/own/markdown/imgs/image-20190928212604438.png)

### datetime 模块

datetime 是 date 和 time 的结合体，包括 date 与 time 的所有信息。datetime 的功能强大，支持 0001 年到 9999 年。

#### 两个常量

datetime.MINYEAR：datetime 所能表示的最小年份

datetime.MAXYEAR：datetime 所能表示的最大年份

#### 五个类

* datetime.date：表示日期的类，常用的属性有 year、month、day
* datetime.time：表示时间的类，常用的属性有 hour、minute、second、microsecond
* datetime.datetime：表示日期时间
* datetime.timedalta：表示时间间隔，即两个时间点之间的长度
* datetime.tzinfo：与时区有关的相关信息

### 日历模块

## 正则表达式

正则表达式是一个特殊字符序列，能帮助用户检查一个字符串是否与某种模式匹配，从而达成快速检索或替换符合某个模式、规则的文本。

Python 自 1.5 版本起增加了 re 模块，它提供了 Perl 风格的正则表达式，re 模块使 Python 语言拥有全部的正则表达式功能。

### 非打印字符

| 实例 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| .    | 匹配除 `\n` 之外的任何单个字符。要匹配包括 '\n' 在内的任意字符，请使用如 `[.\n]` 的模式。当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 |
| \d   | 匹配一个数字字符，等价于 `[0-9]`                             |
| \D   | 匹配一个非数字字符，等价于 `[^0-9]`                          |
| \s   | 匹配任意空白字符，包括空格、制表符、换页符等，等价于 `[\f\n\r\t\v]` |
| \S   | 匹配任意非空白字符，等价于 `[^\f\n\r\t\v]`                   |
| \w   | 匹配包括下划线的任意单词字符，等价于 `[A-Za-z0-9_]`          |
| \W   | 匹配任意非单词字符，等价于 `[^A-Za-z0-9_]`                   |
| \f   | 匹配一个换页符，等价于 `\x0c` 和 `\cL`                       |
| \n   | 匹配一个换行符，等价于 `\x0a` 和 `\cJ`                       |
| \r   | 匹配一个回车符，等价于 `\x0d` 和 `\cM`                       |
| \t   | 匹配一个制表符，等价于 `\x09` 和 `\cl`                       |
| \v   | 匹配一个垂直制表符，等价于 `\x0b` 和 `\cK`                   |

### 特殊字符

| 特殊字符 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| $        | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 `$` 也匹配 `\n` 或 `\r` |
| ()       | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用 |
| *        | 匹配前面的子表达式0次或多次（贪婪模式）                      |
| +        | 匹配前面的子表达式1次或多次（贪婪模式）                      |
| ?        | 匹配前面的子表达式0次或1次（贪婪模式）                       |
| *?,+?,?? | 上面三种特殊字符的非贪婪模式（尽可能少的匹配）               |
| .        | 匹配除换行符 `\n` 之外的任何单字符                           |
| []       | 用于标识一组字符，如果 ^ 是第一个字符，则标识的是一个补集    |
| ?        | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符         |
| \        | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符 |
| ^        | 匹配输入字符的开始位置，除非在方括号表达式中使用，此时它表示不接受任何字符集合 |
| {        | 标记限定符表达式的开始                                       |
| \|       | 指明两项之间的一个选择                                       |

### 限定符

| 字符  | 描述                                                         |
| ----- | ------------------------------------------------------------ |
| *     | 匹配前面的子表达式零次或多次                                 |
| +     | 匹配前面的子表达式一次或多次                                 |
| ?     | 匹配前面的子表达式零次或一次                                 |
| {n}   | n 是一个非负整数。匹配确定的 n 次                            |
| {n,}  | n 是一个非负整数。至少匹配 n 次                              |
| {n,m} | m 和 n 均为非负整数。其中 $ n ≦ m $ 。最少匹配 n 次且最多匹配 m 次 |

### 定位符

| 字符 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| ^    | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，则 `^` 还会与 `\n` 或 `\r` 之后的位置匹配 |
| $    | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，则 `$` 还会与 `\n` 或 `\r` 之前的位置匹配 |
| \b   | 匹配一个单词边界，即字与空格之间的位置                       |
| \B   | 非单词边界匹配                                               |

### re 模块

一般使用 re 的步骤是先将正则表达式的字符串形式编译为 Pattern 实例，然后使用 Pattern 实例处理文本并获得匹配结果（一个 match 函数），最后使用 match 函数获得信息，进行其他操作。

#### re.match 函数

该函数尝试从字符串的起始位置匹配一个模式。如果匹配成功，该方法就返回一个匹配的对象，否则返回 None

该方法只匹配字符串开始的字符，如果开始的字符不符合正则表达式，匹配就会失效，函数返回 None

```python
re.match(pattern, string[, flags=0])

pattern：指匹配的正则表达式
string：要匹配的字符串
flags：标志位，用于控制正则表达式的匹配方式，如是否区分大小写、多行匹配等

# 以下是实例
import re

s = 'hello world'
pt = re.compile(r'hello world')
print(re.match(pt, s))
print(re.match(pt, s).group(0))
print(re.match(pt, s).span())
print(re.match(pt, s).start(0))

# 以下是输出
<re.Match object; span=(0, 11), match='hello world'>
hello world
(0, 11)
0

# 说明
group(0) ：用于返回匹配的整个字符串
span() ：以元组形式返回匹配的起始位置和结束位置
```

##### group 方法

该方法定义如下：

```python
def group(self, *args):
  """Return one or more subgroups of the match.
  :rtype: T|tuple
  """
  pass
```

group([group1, ...]) 方法的作用：

1. 获得一个或多个分组截获的字符串，指定多个参数时以元组的形式返回
2. group1 可以使用编号，也可以使用别名
3. 编号 0 代表整个匹配的字符串
4. 不填写参数时，返回 group(0)
5. 没有截获字符串的组时，返回 None
6. 截获多次字符串的组时，返回最后一次截获的子串

groups([default]) 方法的作用：

1. 以元组的形式返回全部分组截获的字符串，相当于调用 group(1, 2, ..., last)
2. default 参数表示没有截获字符串的组以这个值代替，默认为 None

#### re.search 方法

用于扫描整个字符串并返回第一个成功匹配的字符。如果匹配成功，该方法就返回一个匹配对象，否则返回 None

该方法匹配整个字符串，直到找到一个匹配的对象，匹配结束没找到匹配值才返回 None

```python
re.search(pattern, string, flags=0)

pattern：指匹配的正则表达式
string：要匹配的字符串
flags：标志位，用于控制正则表达式的匹配方式，如是否区分大小写、多行匹配等

# 以下是实例
import re

print(re.search('hello', 'hello world').span()) # 在起始位置匹配
print(re.search('world', 'hello world').span()) # 不在起始位置匹配

# 以下是输出
(0, 5)
(6, 11)
```

### 贪婪模式与非贪婪模式

正则表达式通常使用与查找匹配的字符。Python 里数量词默认是贪婪的，总是尝试尽可能多的字符；非贪婪模式正好相反，总是尝试匹配尽可能少的字符。

```python
import re

print(re.match(r'^(\d+)(0*)$', '102300').groups()) # 贪婪模式
print(re.match(r'^(\d+?)(0*)$', '102300').groups()) # 非贪婪模式

# 以下是输出
('102300', '')
('1023', '00')
```

### 替换

```python
re.sub(pattern, repl, string[, count, flags=0])

作用：
替换字符串中的匹配项

参数：
pattern：正则中的模式字符串
repl：替换的字符串，也可为一个函数
string：要被查找替换的原始字符串
count：模式匹配后替换的最大次数，默认值 0，表示替换所有的匹配

说明：
当 rep1 是一个方法时，这个方法应当只接受一个参数（match 对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）
```

### re.compile 函数

用于编译正则表达式，生成一个正则表达式（Pattern）对象，供 match() 和 search() 这两个函数使用。

```python
re.compile(pattern[, flags])

pattern: 一个字符串形式的正则表达式
flags: 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：
  re.l ：忽略大小写
  re.L ：表示特殊字符集 \w，\W，\b，\B，\s，\S 依赖于当前环境
  re.M ：多行模式
  re.S ：即为 . 并且包含换行符在内的任意字符(. 不包括换行符)
  re.U ：表示特殊字符集 \w，\W，\b，\B，\d，\D，\s，\S 依赖于 Unicode 字符属性数据库
  re.X ：为了增加可读性，忽略空格和 # 后面的注释
```

### 常用函数

| 函数          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| re.match()    | 从字符串的起始位置匹配。匹配成功，返回一个匹配的对象，否则返回 None |
| re.search()   | 扫描整个字符串并返回第一个成功的匹配                         |
| re.findall()  | 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没要找到匹配的，则返回空列表 |
| re.split()    | 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型     |
| re.finditer() | 在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回 |
| re.sub        | 把字符串中所有匹配正则表达式的地方替换成新的字符串           |

## 文件操作

### 读文件流程

1. 只读方式打开文件
2. 读取文件（使用 readline 方法读取文件的每一行。这个方法返回包括行末换行符的一个完整行。所以，当一个空的字符串被返回的时候，即表示文件已经到达了末尾，于是我们停止循环）
3. 关闭文件

### 写文件的流程

1. 可写方式打开文件
2. 写文件操作
3. 关闭文件

### 打开文件

打开文件使用的是 open 函数，语法如下：

```python
open(file_name[, access_mode][, buffering])

file_name : 包含要访问的文件名称的字符串值
access_mode : 打开文件的模式，对应有只读、写入、追加等。access_mode 变量值不是必须的（不带 access_mode 变量时，要求 file_name 存在，否则报异常），默认的文件访问模式为只读（r）
buffering : 如果 buffering 的值被设为 0，就不会有寄存；如果值取 1，访问文件时就会寄存行；如果值为大于 1 的整数，表示这就是寄存区的缓冲大小；如果取负值，寄存区的缓冲大小就是系统默认的值
  
open 函数返回的是一个 File 对象，它代表计算机中的一个文件。
```

| 模式 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| r    | 以只读方式打开文件。文件的指针将会放在文件的开头，这是默认模式 |
| rb   | 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头，这是默认模式 |
| r+   | 打开一个文件用于读写。文件指针将会放在文件的开头             |
| rb+  | 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头 |
| w    | 打开一个文件只用于写入。如果该文件已存在，就将其覆盖；如果不存在，就创建新文件 |
| wb   | 以二进制格式打开一个文件只用于写入。如果该文件已存在，就将其覆盖；如果不存在，就创建新文件 |
| w+   | 打开一个文件用于读写。如果该文件已存在，就将其覆盖；如果不存在，就创建新文件 |
| wb+  | 以二进制格式打开一个文件用于读写。如果该文件已存在，就将其覆盖；如果不存在，就创建新文件 |
| a    | 打开一个文件用于追加。如果该文件已存在，文件指针就会放在文件的结尾。也就是说，新内容将会被写入已有内容之后。如果不存在，就创建新文件进行写入 |
| ab   | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针就会放在文件的结尾。也就是说，新内容将会被写入已有内容之后。如果不存在，就创建新文件进行写入 |
| a+   | 打开一个文件用于读写。如果该文件已存在，文件指针就会放在文件的结尾。也就是说，新内容将会被写入已有内容之后。如果不存在，就创建新文件进行写入 |
| ab+  | 以二进制格式打开一个文件用于读写。如果该文件已存在，文件指针就会放在文件的结尾。也就是说，新内容将会被写入已有内容之后。如果不存在，就创建新文件进行写入 |

> 缓存一般指内存，计算机从内存中读取数据的速度远远大于从磁盘读取数据的速度，一般内存大小远小于磁盘大小，内存的速度比较快，但资源比较紧张。

第二种打开文件的方法：`file('pathname', 'model')`

这两种方法的区别是：

使用 open 函数，文件必须已经存在，否则会报找不到文件的错误；用 file 函数，文件存在就打开，不存在就创建。

### 读和写

f.read() 读出所有内容；f.read(4) 读出前 4 个字符。

f.write() 追加的形式写入；f.tell() 返回所读取文件内字符的长度。

## 常用函数

### filter

#### 语法

```python
filter(function, iterable)

function: 判断函数
iterable：可迭代对象

返回值：
1. Python 3 中返回的是一个 filter 类，filter 类实现了 __iter__ 和 __next__ 方法，可以看成是一个迭代器，有惰性运算的特性，相对 Python 2.x 提升了性能，可以节约内存
2. Python 2 中返回的是过滤后的列表
```

#### 作用

用于过滤序列。它会把传入的函数依次作用于每一个元素，然后根据返回值是 True 还是 False 决定保留还是丢弃该元素。

#### 注意

Python 3 中，filter 的取值方式为：item for item in filter。如果返回的内容需要一个列表，就需要这样写：[item for item in filter]：

```python
print('列表中大于 3 的元素有：', [item for item in filter(lambda x: x > 3,[1,2,3,4,5])])
```

### hex

#### 语法

```python
hex(x)
```

#### 作用

将整数转换为以 0x 为前缀的小写十六进制字符串

#### 实例

如果要将整数转换为大写或小写的十六进制字符串，并可选择有无“0x”前缀，则可以使用如下方法：

```python
print('%#x' % 255, '%x' % 255, '%X' % 255)
print(format(255, '#x'), format(255, 'x'), format(255, 'X'))
print(f'{255:#x}', f'{255:x}', f'{255:X}')

# 以下是输出
0xff ff FF
0xff ff FF
0xff ff FF
```

#### 注意

> 如果要获取浮点数的十六进制字符串形式，请使用 `float.hex()` 方法

### repr

#### 语法

```python
repr(object)
```

#### 作用

将对象转换为供解释器读取的形式

#### 返回值

返回一个对象的 string 形式

#### 扩展

`__repr__()` 是 Python 中的一个特殊方法，由于 object 类已经提供了该方法，而所有的 Python 类都是 object 类的子类，所以所有的 Python 对象，都具有 `__repr__()` 方法。

`__repr__()` 方法默认返回对象的 ”类名 + object at + 内存地址“。

可以在任何类中重写该方法，用于输出自定义的打印。

```python

class test:
    def __init__(self,name,age):
        self.age = age
        self.name = name
    def __repr__(self):
        return "Class_Test[name="+self.name+",age="+str(self.age)+"]"
t = test("Zhou",30)
 
print(t)

# 以下是输出信息
Class_Test[name=Zhou,age=30]
```

### print

#### 语法

```python
print(*objects, sep=' ', end='\n', file=sys.stdout)
```

#### 作用

用于打印输出

#### 参数

- objects -- 复数，表示可以一次输出多个对象。输出多个对象时，需要用 , 分隔。
- sep -- 用来间隔多个对象，默认值是一个空格。
- end -- 用来设定以什么结尾。默认值是换行符 \n，我们可以换成其他字符串。
- file -- 要写入的文件对象。



## 小知识点

1. 在程序的一开始就写如下两行代码，可以在代码移植和编码问题上避免很多问题：

   ```python
   #! /usr/bin/python3     这里写程序的存放路径
   # -*- coding: UTF-8 -*-
   ```

2. 赛风