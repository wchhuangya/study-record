[Toc]

# 语法基础

## 字符集

`js` 是用 `Unicode` 字符集编写的

### 区分大小写

### Unicode 转义序列

为了支持老旧技术，使用 6 个 `ASCII` 字符来表示任意 16 位 `Unicode` 内码。这些 `Unicode` 转义序列均以 `\u` 为前缀，其后跟随 4 个 16 进制数。

这种写法可以用在 `js` 字符串直接量、正则表达式直接量和标识符中（关键字除外）

> 也可以写在注释中，但不会转义哦 :smiley:

## 注释

* 单行注释：`//` ，在此之后的文本都会被 `js` 当做注释忽略掉
* 多行注释：`/*  */` 之间的文本也会被 `js` 当做注释忽略掉
  * 可以跨行
  * 不能嵌套

## 直接量

程序中直接使用的数据值，包括：

* 数字
* 使用单或双引号括起来的字符串
* 布尔值
* 正则表达式直接量
* `null`

## 标识符和保留字

* 标识符：是一个名字
  * 用来对变量和函数进行命名
  * 以 **字母、下划线、美元符** 开始，后续字符可以是 **字母、下划线、美元符、数字**
* `js` 使用一些标识符当做保留字，程序中不能使用保留字当做标识符

> 用的时候添加保留字的表格

## 可选的分号

* 一般可以省略
* 涉及 `return、break、continue` 的时候不要省略
* 涉及 `++ 、--` 运算符的时候不要省略

# 类型、值、变量

## 原始类型

### 数字

`js` 中所有的数字均用浮点数值表示

算数运算时在溢出、下溢、或被 0 整除时不会报错：

* 发生上溢，结果为 `Infinity`
* 负数值超过负数范围，结果为 `-Infinity`
* 下溢（运算结果无限接近于 0 并比 `js` 所能表示的最小值还小的时候发生的一种情形）时，结果为 0
* 负数下溢时，结果为 -0
* `0 / 0` 的结果是 `NaN`

#### 整形直接量

* 十进制：用一个数字序列直接表示
* 十六进制：以 `0x` 或者 `0X` 为前缀，其后跟 **十六进制数串** 的直接量
* 八进制：以数字 0 开始，其后跟随一个由 0~7 之间的数字组成的序列。==最好不要使用== 

#### 浮点直接量

* 由整数部分，小数点，小数部分组成
* 可以使用指数计数法表示

> `js` 采用的是 **二进制浮点数** ，会有精度的问题。因此，在进行金融计算时，尽可能使用整数，不要使用小数进行基于货币单位的运算

#### 非数字值

`NaN`

### 判断 NaN 的方法

```javascript
if (num != num)

// 上面的识字，当且仅当 num = NaN 时成立
```



### 文本

字符串是一组由 16 位值组成的不可变的有序序列

> `js` 中，没有表示单个字符的 “字符型”

#### 字符串直接量

由单引号或双引号括起来的字符序列

#### 转义字符

反斜杠（`\`）有特殊的用途，反斜杠后面加一个字符，就不再表示它的字面含义了

#### 正则直接量

1. 在两条斜线（`\`）之间的文本构成了一个正则表达式直接量
2. 第二条斜线之后也可以跟随一个或多个字母，用来修饰匹配模式的含义

### 布尔值

* 布尔值指代真或假、开或关、是与否
* 共类型只有两个值：保留字 `true` 、 `false`

### null

表示一个特殊值，用来描述 “空值”

### undefined

表示一种更深层次的 “空值”，表明变量没有初始化

* 如果在查询对象或数组元素的值时返回 `undefined` ，则说明这个属性或元素不存在
* 如果函数没有任何返回值，则返回 `undefined`

## 对象类型

### 全局对象

全局对象的属性是全局定义的符号，`js` 程序可以直接使用。当 `js` 解释器启动时（或者任何 `Web` 浏览器加载新页面时），它将创建一个新的全局对象，并给它一组定义的初始属性：

* 全局属性：`undefined、Infinity、NaN` 等

* 全局函数：`isNaN()、parseInt()、eval()` 等
* 构造函数：`Date()、RegExp()、String()、Object()、Array()` 等
* 全局对象：`Math、JSON` 等

在代码的最顶级，即不再任何函数内的 `js` 代码，可以使用 `js` 关键字 `this` 来引用全局对象：

```javascript
var global = this;  // 定义一个引用全局对象的全局变量
```

### 包装对象

字符串、数字、布尔值的包装对象有别于对象，它的属性（比如 length 属性）都是只读的，并且不能给他们定义新属性。

> * **==** 等于运算符将原始值和其包装对象视为相等，**===** 全等运算符将它们视为不相等
> * **typeof** 运算符可以看出原始值和包装对象的不同

## 不可变的原始值和可变的对象引用

* 原始值是不可改变的：任何方法都无法更改（或 ”突变“）一个原始值；原始值的比较是值的比较
* 对象的值是可以修改的：对象的比较时引用的比较

## 类型转换

![image-20200606115940508](/Users/wchya/own/markdown/imgs/image-20200606115940508.png)

### 隐式类型转换

要注意的是：一个值转换为另外一个值，并不意味着这两个值相等。

### 显式类型转换

显式类型转换最简单的方法就是使用 `Boolean()、Number()、String()、Object()` 函数。

> 在上面的四个方法前使用 new 关键字，是用作包装对象的；
>
> 不使用 new 关键字，直接使用上面的四个方法，才是显式做类型转换的；
>
> 如果试图把 null 或者 undefined 转换为对象，会抛出一个类型错误 **TypeError**

`Number` 类定义的 `toString()` 方法可以接受表示转换基数的可选参数（范围是 2~36）

对象到字符串的转换步骤：

* 如果对象具有 `toString()` 方法，则调用这个方法。如果他返回一个原始值，`js` 将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串结果
* 如果对象没有 `toString()` 方法，或者这个方法并不返回一个原始值，那么 `js` 会调用 `valueOf()` 方法。如果存在这个方法，则 `js` 调用它。如果返回值是原始值，`js` 将这个值转换为字符串，并返回这个字符串的结果
* 否则，`js` 无法从 `toString()` 或 `valueOf()` 获得一个原始值，因此这时它将抛出一个类型错误异常

对象到数字的转换步骤：

* 如果对象具有 `valueOf()` 方法，后者返回一个原始值，则 `js` 将这个原始值转换为数字并返回这个数字
* 否则，如果对象具有 `toString()` 方法，后者返回一个原始值，则 `js` 将其转换并输出
* 否则，`js` 抛出一个类型错误异常

## 变量声明

变量使用 `var` 关键字来声明

### 重复的声明和遗漏的声明

* 重复声明和赋值语句没什么两样
* 如果给一个未声明的变量赋值，`js` 实际会给全局对象创建一个同名属性

## 变量作用域

* 一个变量的作用域是程序源码中定义这个变量的区域
* 局部变量的优先级高于同名的全局变量

### 函数作用域和申明提前

`js` 的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的

### 作为属性的变量

* 使用 `var` 关键字声明的变量时不可配置的，即不能使用 `delete` 运算符删除
* 给变量（包括全局变量）新增的属性是可以使用 `delete` 属性删除的

### 作用域链⛓

每一段 `js` 代码都有一个与之关联的作用域链，它是一个对象列表或者链表，这组对象定义了这段代码 ”作用域中“ 的变量

# 表达式和运算符

## 原始表达式

* 原始表达式是表达式的最小单位，因为它们不再包含其他表达式
* 原始表达式包含常量、字节量、关键字和变量

## 对象和数组的初始化表达式

对象和数组的初始化表达式实际上是一个新创建的对象和数组，也称作 ”对象直接量“ 和 ”数组直接量“

## 函数定义表达式

函数定义表达式用于定义一个 `js` 函数，表达式的值是这个新定义的函数，也可以被称为函数直接量

## 属性访问表达式

* `表达式.属性` 
* `表达式[属性]` ：适用于对象和数据

## 调用表达式

`js` 中的调用表达式是一种调用（或执行）函数或方法的语法表示，以一个函数表达式开始，这个函数表达式指代了要调用的函数。函数表达式后跟随一对圆括号，括号内是一个以逗号隔开的参数列表，参数可以有 0 个也可以有多个

## 对象表达式

对象表达式创建一个对象并调用一个函数（这个函数称作构造函数）初始化新对象的属性，例如：

`new Object()`

如果一个对象表达式不需要传入任何参数给构造函数的话，那么圆括号是可以省略掉的：

`new Object`

## 运算符

![image-20200606231030232](/Users/wchya/own/markdown/imgs/image-20200606231030232.png)![image-20200606231054135](/Users/wchya/own/markdown/imgs/image-20200606231054135.png)

## 算数表达式

## 关系表达式

## 逻辑表达式

## 赋值表达式

## 表达式计算

## 其他运算符

# 语句

## 表达式语句

## 复合语句和空语句

## 声明语句

## 条件语句

## 循环

## 跳转

## 其他语句类型

## JavaScript 语句小结

# 对象

对象除了 **名字和值** 以外，每个属性还有一些与之相关的值，称为 **属性特性** ：

* 可写，表明是否可以设置该属性的值
* 可枚举，表明是否可以通过 `for/in` 循环返回该属性
* 可配置，表明是否可以删除和配置该属性

除了包含 **属性** 以外，每个对象还拥有三个相关的对象特性：

* 对象的原型指向另外一个对象，本对象的属性继承自它的原型对象
* 对象的类是一个表示对象类型的字符串
* 对象的扩展标记指明了是否可以向该对象添加新属性

**三类 JS 对象和两类属性** ：

* 内置对象：由 `ECMAScript` 规范定义的对象或类，例如：数组、函数、日期、正则表达式都是内置对象
* 宿主对象：由 `js` 解释器所嵌入的宿主环境（比如 `Web` 浏览器）定义的。客户端 `js` 中表示网页结构的 `HTMLElement` 对象均是宿主对象。既然宿主环境定义的方法可以当成普通的 `js` 函数对象，那么宿主对象也可以当成内置对象
* 自定义对象：由运行中的 `js` 代码创建的对象
* 自由属性：直接在对象中定义的属性
* 继承属性：在对象的原型对象中定义的属性

## 创建对象

### 对象直接量

对象直接量是由若干键值对组成的映射表，键值对中间用冒号分隔，键值对之间用逗号分隔，整个映射表用花括号括起来。

属性名可以是 `js` 标识符也可以是字符串直接量（包括空字符串）。属性的值可以是任意类型的 `js` 表达式，表达式的值（可以是原始值也可以是对象）就是这个属性的值。

```javascript
var empty = {};
var point = {
  x: point.x,
  y: point.y
};
```

> 1. 对象直接量是一个表达式，这个表达式的每次运算都创建并初始化一个新的对象
> 2. 每次计算对象直接量的时候，也都会计算它的每个属性的值
> 3. 也就是说，如果在一个重复调用的函数中的循环体内使用了对象直接量，它将创建很多新对象，并且每次创建的对象的属性值也有可能不同

### 通过 new 创建对象

`new` 运算符创建并初始化一个新对象，`new` 关键字后面跟一个函数调用，这里的函数称作构造函数，用于初始化一个新创建的对象。

```javascript
var o = new Object(); // 创建一个空对象，和 {} 一样
var a = new Array(); // 创建一个空数组，和 [] 一样
var d = new Date(); // 创建一个表示当前时间的 Date 对象
var r = new RegExp("js"); // 创建一个可以进行模式匹配的 RegExp 对象
```

### 原型

每一个 `js` 对象（`null` 除外）都和原型相关联，每一个对象都从原型继承属性

所有通过对象直接量创建的对象都具有同一个原型对象，并可以通过 `js` 代码 `Object.prototype` 获得对原型对象的引用

通过对象直接量创建的对象使用 `Object.prototype` 作为它们的原型，通过 `new` 创建的对象使用构造函数的 `prototype` 属性作为它们的原型，通过 `Object.create()` 创建的对象使用第一个参数（也可以是 `null`）作为它们的原型

原型链中的方法和属性没有复制到其它对象——它们要被访问需要通过原型链的方式来访问

`prototype` 属性的值是一个对象，希望被下游的原型链继承的属性和方法，都被存储在其中

一种常见的对象定义模式是：在构造器中定义属性，在 `prototype` 上定义方法

***任何*您想要被继承的方法都应该定义在构造函数的`prototype`对象里，并且*永远*使用父类的`prototype`来创造子类的`prototype`，这样才不会打乱类继承结构。**

### Object.create()

用途：创建一个新对象

第一个参数：新对象的原型

第二个参数：对对象的属性进行进一步的描述

> 1. 通过传入参数 null 来创建一个没有原型的新对象，通过这种方式创建的对象不会继承任何东西
> 2. 创建一个普通的空对象的方法：第一个参数传入 {} 或者 Object.prototype

## 属性的查询与设置

* 可以使用点（`.`）或者方括号（`[]`）运算符来获取属性的值

* 运算符左侧是一个返回对象的表达式
* 对于点（`.`）来说，右侧必须是一个以属性名称命名的简单标识符
* 对于方括号（`[]`）来说 ，方括号内必须是一个计算结果是字符串的表达式，这个字符串就是属性的名字

> 如果对象的属性名是保留字，必须使用方括号的形式访问它们

### 关联数组

### 继承

**查找对象属性的步骤**

假设要查询对象 `o` 的属性 `x` ，如果 `o` 中不存在 `x`，那么将会继续在 `o` 的原型对象中查询属性 `x`。如果原型对象中也没有 `x`，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到 `x` 或者查找到一个原型是 `null` 的对象为止。

可以看到，对象的原型属性构成了一个 “链”，通过这个 “链” 可以实现属性的继承。

赋值操作总是在原始对象上创建属性或对已有的属性赋值，而不会去修改原型链

### 属性访问错误

查询一个不存在的属性并不会报错，但是，如果对象不存在，那么视图查询这个不存在的对象的属性就会报错。

下面是一种赋值的办法：

```javascript
var len = book && book.subtitle && book.subtitle.length;
```

## 删除属性

* `delete` 运算符可以删除对象的属性，但它只是断开属性和宿主对象的联系，而不会去操作属性中的属性
* `delete` 运算符只能删除自有属性，不能删除继承属性

> 销毁对象的时候，要遍历属性中的属性，依次删除

## 检测属性

`in` 运算符可以判断某个属性是否存在于某个对象中，`in` 运算符的左侧是属性名（字符串），右侧是对象。

## 枚举属性

对象继承的内置方法不可枚举，但在代码中给对象添加的属性都是可枚举的

## getter 和 setter 属性

由 `getter` 和 `setter` 定义的属性称作 “存取器属性” ，它不同于数据属性，数据属性只有一个简单的值。

* 当程序查询存取器属性的值时，`js` 调用 `getter` 方法（无参），这个方法的返回值就是属性存取表达式的值
* 当程序设置一个存取器属性的值时，`js` 调用 `setter` 方法，将赋值表达式右侧的值当做参数传入 `setter`
* 和数据属性不同，存取器属性不具有可写性
* 如果属性同时具有 `getter` 和 `setter` 方法，那么它是一个只读属性
* 如果属性只有 `getter` 方法，那么它是一个只读属性
* 如果属性只有 `setter` 方法，那么它是一个只写属性，读取只写属性总是返回 `undefined`

## 属性的特性

属性除了包含名字和值之外，还包含一些标识它们可写、可枚举和可配置的特性。

可以认为一个属性包含一个名字和四个特性

数据属性的描述符对象的属性有 `value，writable，enumberable，configurable` ，存取器属性的描述符对象则用 `get，set` 属性代替 `value，writable` 。

通过调用 `Object.getOwnPropertyDescriptor()` 可以获得某个对象特定属性的属性描述符：

```javascript
var obj = {
        x: 1,
        get y_t() {
            return Math.random();
        },
        set y_s(s) {
            console.log(s);
        }
    }
console.log(Object.getOwnPropertyDescriptor(obj, "y_t"));

/*
{set: undefined, enumerable: true, configurable: true, get: ƒ}
configurable: true
enumerable: true
get: ƒ y_t()
set: undefined
__proto__: Object
/*
```

> 注意：1. 上述方法只能得到自有属性的描述符；2. 可以通过遍历原型链，获得继承属性的特性；

通过调用 `Object.defineProperty()` ，传入要修改的对象、要创建或修改的属性的名称以及属性描述符对象，可以设置属性的特性，或者让新建属性具有某种特性

```javascript
var o = {}; // 创建一个新对象
// 添加一个不可枚举的数据属性 x，并赋值为 1
Object.defineProperty(o, "x", {value: 1, writeable: true, enumerable: false, configurable: true});

// 属性存在，但是不可枚举
console.log(o.x);
console.log(Object.keys(o));

// 现在对属性 x 进行修改，让他变成只读
Object.defineProperty(o, 'x', {writable: false});
// 试图更改这个属性的值
o.x = 2;
// 修改失败但是不报错，但是在严格模式下抛出类型错误异常
console.log(o.x);

// 属性是可配置的，因此可以通过下面的方式对它进行修改
Object.defineProperty(o, 'x', {value: 3});
console.log(o.x);

// 现在将数据属性修改为存取其属性
Object.defineProperty(o, 'x', {get: function () { return 0 }});
console.log(o.x);
```

## 对象的三个属性

每一个对象都有与之相关的原型（`prototype`）、类（`class`）和可扩展性（`extensible attribute`）。

### 原型属性

* 查询对象的原型：`Object.getPrototpyeOf(obj)`
* 检查对象 `p` 是否对象 `o` 的原型：`p.isPrototypeOf(o)`

### 类属性

```javascript
/**
 * 获取指定对象的字符串类型描述
 * @param o 要获取类型描述的对象
 * @returns {string} 类型描述字符串
 */
function classof(o) {
    if (o === null) return 'Null';
    if (o === undefined) return 'Undefined';
    return Object.prototype.toString.call(o).slice(8, -1);
}
```

### 可扩展性

* 判断对象是否可扩展：`Object.isExtensible(o)`

* 将对象转换为不可扩展的：`Object.preventExtensions(o)`

  > 1. 一旦将对象转换为不可扩展的，就无法再将其转换回可扩展的了
  > 2. 该方法只影响到对象本身的可扩展性

* 将对象设置为不可扩展，将对象的自有属性设置为不可配置：`Object.seal()`

* 将对象设置为不可扩展，将对象的自有属性设置为不可配置，将自有的所有数据属性设置为只读：`Object.freeze(o)`

  > 如果对象的存取器具有 setter 方法，存取其属性将不受影响，仍可以通过给属性赋值调用它们

## 序列化对象

* `ECMAScript 5` 提供了内置函数 `JSON.stringify()` 和 `JSON.parse()` 用来序列化和还原 `js` 对象 
* `JSON` 语法支持对象、数组、字符串、无穷大数字、`true`、`false`、`null` ，可以将它们序列化和还原

## 对象方法

### toString() 方法

该方法将返回一个表示调用这个方法的对象值的字符串

### toLocaleString() 方法

该方法返回一个表示这个对象的本地化字符串

### valueOf() 方法

该方法与 `toString()` 方法非常类似，但往往当 `js` 需要将对象转换为某种原始值而非字符串的时候才会调用它

# 数组

* 数组是值的有序集合
* 每一个值叫做一个元素
* 每个元素在数组中有一个位置，以数字表示，称为索引
* 数组元素可以是任意类型

## 创建数组

* 数组直接量：在 **方括号中** 将数组元素用逗号隔开

  > 1. 数组直接量中的值不一定要是常量，它们可以是任意的表达式
  > 2. 可以包含对象直接量或其他数组直接量
  > 3. 如果省略数组直接量中的某个值，省略的元素将被赋予 undefined 值
  > 4. 数组直接量的语法允许有可选的结尾的逗号

* 构造函数：`Array()`

  * `var arr = new Array();`
  * `var arr = new Array(10);`
  * `var arr = new Array(1,2,3,'sdf',{x:1,y:22})`

## 数组元素的读和写

* 使用 `[]` 操作符来访问数组中的一个元素
* 数组的引用位于方括号的左边
* 方括号中是一个返回非负整数值的任意表达式
* 使用该语法既可以读又可以写数组的一个元素

## 稀疏数组

稀疏数组：包含从 0 开始的不连续索引的数组。

## 数组长度

* 在给数组赋值时，如果赋值的索引大于或等于数组的长度，那么数组的 `length` 属性会加 1
* 把数组的长度变为一个小于当前长度的非负整数时，数组中索引小于等于该整数的值都会被删除

## 数组元素的添加和删除

## 数组遍历

对于非稀疏数组，最好使用 `for` 循环；对于稀疏数组，最好使用 `for/in` 循环；

* 使用 `for` 循环

  * 排除 `null，undefined` 和不存在的元素：`if (!a[i]) continue;`

  * 排除 `undefined` 和不存在的元素：`if (a[i] === undefined) continue;`

  * 排除不存在的元素：`if (!(i in a)) continue;`

    > `i` 为循环变量，`a` 为被循环的数组

* 使用 `for/in` 循环

  * 循环每次将一个可枚举的属性名（包括数组索引）赋值给循环变量

  * 可以枚举继承的属性名

    ```javascript
    Array.prototype.xx = function (x) {
      console.log(x);
    };
    var a = ['sdf', '32', '32fsd','j9ad8'];
    for (var aa in a) {
      if (!a.hasOwnProperty(aa)) // 排除 a 的继承属性
        continue;
      console.log(a[aa]);
    }
    
    /* 下面是输出
    sdf
    32
    32fsd
    j9ad8
    */
    ```

* 使用 `forEach` 循环

  * 按照索引的顺序依次传递给定义的一个函数

    ```javascript
    var a = ['sdf', '32', '32fsd','j9ad8'];
    var sum = 0;
    a.forEach(function (value) {
      var num = parseInt(value);
      if (num === num)
        sum += num;
    });
    console.log(sum);
    
    /* 以下是输出
    64
    */
    ```

## 多维数组

`js` 不支持真正的多维数组，但可以使用数组的数组来近似：

```javascript
// ********** 99 乘法表 *********
var res = new Array(9);
for (var i = 0, len = res.length; i < len; i++)
  res[i] = new Array(i + 1);

for (var i = 0, len = res.length; i < len; i++)
  for (var j = 0; j < i + 1; j++)
    res[i][j] = ((i + 1) + ' * ' + (j + 1) + ' = ') + ((i + 1) * (j + 1));

for (var i = 0, len = res.length; i < len; i++) {
  var s = '';
  for (var j = 0, len2 = res[i].length; j < len2; j++)
    s += res[i][j] + '    ';
  console.log(s);
}
```

## 数组方法

### join()

**作用：**将数组中所有元素都转换为字符串并连接在一起

**参数：**在生成的字符串中用来分隔数组中的各个元素。如果不指定，默认使用逗号

**返回：**最后生成的字符串

### reverse()

**作用：**将数组中的元素颠倒顺序

**参数：**无

**返回：**逆序后的数组

> 该方法不通过重新排列的元素创建新的数组，而是在原先的数组上重新排列它们

### sort()

**作用：**将数组中的元素排序并返回排序后的数组

**参数：**比较函数，可以省略，省略后数组元素将以字母表顺序排序

**返回：**排序后的数组

**排序函数：**该函数决定了它的两个参数在排好序的数组中的先后顺序。如果第一个参数应该在前，比较函数应该返回一个小于 0 的值；如果第一个参数应该在后，比较函数应该返回一个大于 0 的值；加入它们的顺序无关紧要，函数应该返回 0

> 如果数组中包含 undefined 元素，将会被排到数组的尾部

### concat()

**作用：** 连接多个元素，创建一个新数组

**参数：** 用于创建新数组的元素（包括调用 **concat()** 的原始数组）

**返回：** 连接后的新数组 

### slice()

**作用：** 截取数组片段

**参数：** 指定了片段的开始位置和结束位置。如果只指定一个参数，返回的数组将包含从开始位置到数组结尾的所有元素；如果参数中出现了负数，它表示相对于数组中最后一个元素的位置

**返回：** 截取后的片段

### splice()

**作用：** 在数组中插入或删除元素的通用方法

**参数：** 第一个参数制定了插入和（或）删除的起始位置，第二个参数指定了应该从数组中删除的元素个数。如果省略第二个参数，从起始点开始到数组结尾的所有元素都将被删除

**返回：** 返回一个由删除元素组成的数组，如果没有删除元素就返回一个空数组

> 注意区别于 concat() 和 splice() ，它们会插入数组的本身而不是数组的元素

### push() 和 pop()

**作用：** 允许将数组当做栈来使用，对数组元素进行入栈和出栈的操作

**参数：** `push()` 方法的参数是入栈的元素，`pop()` 无参数

**返回：** `push()` 方法返回数组新的长度，`pop()` 返回删除的值

> 注意：这两个方法都修改并替换原始数组而非生成一个修改版的新数组

### unshift() 和 shift()

**unshift() ：** 在数组的头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获得足够的空间，最后返回数组新的长度

**shift() ：** 删除数组的第一个元素并将其返回，然后把所有随后的元素下移一个位置来填补数组头部的空缺

## ECMAScript 5 中的数组方法

`ECMAScript 5` 中的大多数数组方法的参数讲解：

* 大多数方法的第一个参数接受一个函数，并且对数组的每个元素（或一些元素）调用一次该函数。如果是稀疏数组，对不存在的元素不调用传递的函数
* 在大多数情况下，调用提供的函数使用三个参数：数组元素、元素的索引和数组本身，通常只需要提供第一个参数就够用了

### forEach()

从头至尾遍历数组，为每个元素调用指定的函数。

### map()

将调用的数组的每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值

> 1. 传递给 map() 的函数应该有返回值
> 2. map() 返回的是新数组，不会修改调用的数组

### filter()

过滤数组的元素，返回的数组元素时调用数组的一个子集。传递的函数是用来逻辑判定的：如果返回值为 `true` 或能转换为 `true` 的值，那么传递给判定函数的元素就是这个子集的成员，它将被添加到一个作为返回值的数组中。

> 注意：filter() 会跳过稀疏数组中缺少的元素，它的返回数组总是稠密的

```javascript
// 以下代码可以压缩稀疏数组的空缺
var sparse = [1, '32', 23, undefined, 2, null];
sparse[50] = 223;
var dens = sparse.filter(function () { return true; });
console.log(sparse);
console.log(dens);
/** 输出为
(51) [1, "32", 23, undefined, 2, null, empty × 44, 223]
(7) [1, "32", 23, undefined, 2, null, 223]
*/

// 以下代码可以压缩空缺，还能删除数组中的 undefined 和 null 值
dens = sparse.filter(function (value) { return value !== undefined && value !== null });
console.log(sparse);
console.log(dens);
/** 输出为
(51) [1, "32", 23, undefined, 2, null, empty × 44, 223]
(5) [1, "32", 23, 2, 223]
*/
```

### every() 和 some()

用于数组的逻辑判定：对数组元素应用指定的函数进行判断，返回 `true` 或 `false`

* `every()` 
  * 当且仅当针对数组中的所有元素调用判定函数都返回 `true` ，它才返回 `true`
  * 判定函数第一次返回 `false` 后就返回 `false`
  * 判定函数一直返回 `true` ，它将会遍历整个数组
* `some()` 
  * 当数组中至少有一个元素调用判定函数返回 `true` ，它就返回 `true` 
  * 当且仅当数值中的所有函数调用判定函数都返回 `false` ，它才返回 `false`
  * 判定函数第一次返回 `true` 后就返回 `true`
  * 判定函数一直返回 `false` ，它将会遍历整个数组

> 在空数组上调用时，every() 返回 true，some() 返回 false

### reduce() 和 reduceRight()

使用指定的函数将数组元素进行组合，生成单个值。

`reduce()` 需要两个参数。第一个是执行化简操作的函数，化简函数的任务就是用某种方法把两个值组合或化简为一个值，并返回化简后的值；第二个（可选）的参数是一个传递给函数的初始值。

化简函数的参数：第一个是到目前为止的化简操作积累的结果，第一次调用函数时，第一个参数是一个初始值，它就是传递给 `reduce()` 的第二个参数

`reduceRight()` 的工作原理和 `reduce()` 一样，不同的是它按照数组索引从高到低（从右到左）处理数组，而不是从低到高。

### indexOf() 和 lastIndexOf()

搜索整个数组中具有给定值的元素，返回找到的第一个元素的索引或者如果没有找到就返回 -1。

`indexOf()` 从头至尾搜索，而 `lastIndexOf()` 则反向搜索

第一个参数是需要搜索的值，第二个参数是可选的：它指定数组中的一个索引，从那里开始搜索。如果省略该参数，`indexOf()` 从头开始搜索，而 `lastIndexOf()` 从末尾开始搜索。第二个参数也可以是负数，它代表相对数组末尾的偏移量。

## 数组类型

检测数组的方法：`Array.isArray(obj)`

## 类数组对象

`js` 数组的特性：

* 当有新的元素添加到列表中时，自动更新 `length` 属性
* 设置 `length` 为一个较小值将截断数组
* 从 `Array.prototype` 中继承一些有用的方法
* 其类属性为 `Array`

```javascript
/**
 * 判定 o 是否是一个类数组对象
 * 字符串和函数有 length 属性，但是它们可是使用 typeof 检测将其排除
 * 在客户端 js 中，DOM 文本节点也有 length 属性，需要使用额外判断 o.nodeType != 3 将其排除
 * @param o 要判断的对象
 * @returns {boolean} 判断结果
 */
function isArrayLike(o) {
    if (o &&                                    // o 非 null、undefined等
        typeof o === 'object' &&                // o 是对象
        isFinite(o.length) &&                   // o.length 是有限数值
        o.length > 0 &&                         // o.length 是非负数
        o.length === Math.floor(o.length) &&    // o.length 是整数
        o.length < 4294967296                   // o.length < 2^32
    )
        return true;                            // o 是类数组对象
    else
        return false;                           // o 不是类数组对象
}
```



## 作为数组的字符串

字符串是不可变值，故当把它们作为数组看待时，它们是只读的。

使用数组方法来修改字符串传会导致错误，并且出错时没有提示。

# 函数

函数是这样的一段 `js` 代码：他只定义一次，但可能被执行或调用任意次

## 函数定义

函数定义都从 `function` 关键字开始，其后跟随这些组成部分：

* 函数名称标识符。这个名字是可选的，如果存在，该名字只存在于函数体中，并指代该函数对象本身
* 一对圆括号。包含由 0 个或多个用逗号隔开的标识符组成的列表
* 一对花括号。包含 0 条或多条 `js` 语句

## 嵌套函数

`js` 中，函数可以嵌套在其他函数里。

嵌套函数可以访问嵌套它们（或多重嵌套）的函数的参数和变量。

## 函数调用

构成函数主体的 `js` 代码在定义之时并不会被执行，只有调用该函数之时，它们才会执行，有 4 中方式来调用 `js` 函数：

* 作为函数
* 作为方法
* 作为构造函数
* 通过它们的 `call()` 和 `apply()` 方法直接调用

以函数形式调用的函数通常不使用 `this` 关键字，不过，`this` 可以用来判断当前是否是严格模式：

```javascript
var strict = (function () {return !this;}());
```

### 方法调用

任何函数只要作为方法调用实际上都会传入一个隐藏的参数——`this` ，方法调用的母体就是这个对象

> this 是一个关键字，不是变量，也不是属性名，不允许给 this 赋值

* `this` 没有作用域的限制，嵌套的函数不会从调用它的函数中继承 this
* 如果嵌套函数作为方法调用，其 `this` 的值指向调用它的对象
* 如果嵌套函数作为函数调用，其 `this` 值不是全局对象（非严格模式下）就是 `undefined`（严格模式下）

### 构造函数调用

构造函数调用创建一个空的新对象，这个函数继承自构造函数的 `prototype` 属性

构造函数通常不使用 `return` 关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。

### 间接调用

`call()` 和 `apply()` 方法可以间接地调用函数。

`call()` ：这个函数允许你调用一个在这个文件里别处定义的函数。第一个参数指明了在你运行这个函数时想对“`this`”指定的值，也就是说，你可以重新指定你调用的函数里所有“`this`”指向的对象

## 函数的形参和实参

### 可选形参

当调用函数的时候传入的是实参比函数声明时指定的形参个数要少，剩下的形参都将设置为 `undefined` 值，因此在调用参数时形参是否可选以及是否可以省略应当保持较好地适应性：

```javascript
/**
 * 遍历 o 对象的属性，并将其加入 a 数组中
 * @param o 待遍历的对象
 * @param a 接受对象属性名的数组，如果不传，就创建一个新数组
 * @returns {Array}  保存 o 中属性名称的数组
 */
function getPropertyNames(o, /* optional */ a) {
    a = a || [];
    for (var property in o)
        a.push(property);
    return a;
}
```

### 可变长的实参列表：实参对象

当调用函数的时候传入的参数个数超过函数定义时的形参个数时，没有办法直接获得未命名值的引用。参数对象解决了这个问题。在函数体内，标识符 `arguments` 是指向实参对象的引用，实参对象是一个类数组对象，这样可以通过数字下标就能访问传入函数的实参值，而不用非要通过名字来得到实参。

### 将对象属性用作实参

当一个函数包含超过三个形参，对于程序员来说，要记住调用函数中实参的正确顺序实在让人头疼。为了每次都不翻阅手册这么麻烦，最好通过键/值对的形式来传入参数，这样参数的顺序就无关紧要了。

## 作为值的函数

可以将函数赋值给变量，存储在对象的属性或数组的元素中

### 自定义函数属性

`js` 中的函数并不是原始值，而是一种特殊的对象，也就是说，函数可以拥有属性。

## 作为命名空间的函数

## 闭包

## 函数属性、方法和构造函数

### length 属性

### prototype 属性

每一个函数都包含一个 `prototype` 属性，这个属性是指向一个对象的引用，这个对象称作 “原型对象” 。每一个函数都包含不同的原型对象，当将函数用作构造函数的时候，新创建的对象就会从原型对象上继承属性。

### call() 方法和 apply() 方法

### bind() 方法

### toString() 方法

### Function() 构造函数

### 可调用的对象

## 函数式编程

### 使用函数处理数组

### 高阶函数

### 不完全函数

### 记忆

# 类和模块

## 类和原型

`js` 中，类的所有实例都从同一个原型对象上继承属性。

## 类和构造函数

### 构造函数和类的标识

原型对象是类的唯一标识：当且仅当两个对象继承自同一个原型对象时，它们才是属于同一个类的实例。

```javascript
r instanceof Range // 如果 r 继承自 Range.prototype ，则返回 true
```



`instanceof` 运算符并不会检查 `r` 是否由 `Range()` 构造函数初始化而来，而会检查 `r` 是否继承自 `Range.prototype`

### constructor 属性

每个 `js` 函数（`ECMAScript5` 中的 `Function.bind()` 方法返回的函数除外）都自动拥有一个 `prototype` 属性。这个属性的值是一个对象，这个对象包含唯一一个不可枚举属性 `constructor` 。`constructor` 属性的值是一个函数对象。

```javascript
var F = function(){};		// 这是一个函数对象
var p = F.prototype;		// 这是F相关联的原型对象
var c = p.constructor;	// 这是与原型相关联的函数
c === F									// => true; 对于任意函数 F.prototype.constructor === F
```

## js 中 Java 式的类继承

**名词解释：**

* **实例字段：**它们是基于实例的属性或变量，用以保存独立对象的状态
* **实例方法：**它们是类的所有实例共享的方法，由每个独立的实例调用
* **类字段：**这些属性或变量时属于类的，而不是属于类的某个实例的
* **类方法：**这些方法是属于类的，而不是属于类的某个实例的

`js` **的三种对象：**

* **构造函数对象：**为 `js` 的类定义了名字。任何添加到这个构造函数对象中的属性都是类字段和类方法（如果属性值是函数的话就是类方法）
* **原型对象：**原型对象的属性被类的所有实例所继承，如果原型对象的属性值是函数的话，这个函数就作为类的实例的方法来调用
* **实例对象：**类的每个实例都是一个独立的对象，直接给这个实例定义的属性是不会为所有实例对象所共享的。定义在实例上的非函数属性，实际上是实例的字段

> 1. js 的实例方法必须使用关键字 this 来存取实例的字段
> 2. 常量命名一般都是大写
> 3. 下划线前缀表名类的 “私有” 字段，表明类是内部使用的，而不属于类的共有 API 部分

## 类的扩充

`js` 中基于原型的继承机制是动态的：对象从其原型继承属性，如果创建原型之后原型的属性发生改变，也会影响到继承这个原型的所有实例对象。

## 类和类型

实例对象的 `class` 属性都是 `Object`

### instanceof 运算符

左操作符是待检测的类对象，右操作数是定义类的构造函数

> 这里的继承可以不是直接继承

构造函数是类的公共标识，但原型是唯一的标识。

使用 `isPropertyOf()` 方法检测对象的原型链上是否存在某个特定的原型对象